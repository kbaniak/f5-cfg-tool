#!/usr/bin/perl -w

#
# (C) Krystian Baniak 2019
#
# contact: krystian.baniak@exios.pl
# license: MIT
# program: f5-cfg
# description: tool for managing F5 LTM devices via iControl REST
#              allows for batch processing for complex transactions
#

use strict;
use warnings;

# remember from where we are called
my $rundir = $ENV{PWD};

BEGIN {
  use Cwd;
  use File::Basename;
  $rundir = qx{pwd};
  my $__base = dirname(__FILE__);
  if ( -l __FILE__) {
    $__base = dirname(readlink(__FILE__));
  }
  chdir($__base) || die ". cannot chdir into $__base";
  push (@INC, "./lib");
  printf ". runtime location: %s, rundir: %s\n", getcwd(), $rundir;
}

use Switch;
use JSON;
use Data::Dumper;
use HTTP::Request::Common;
use HTTP::Request;
use Getopt::Std;
use LWP::UserAgent;
use Digest::SHA qw(sha1 sha1_hex sha1_base64);
use File::Path qw(remove_tree);
use POSIX qw(strftime);
use Text::Diff;
use IO::Tee;

use CAudit;
use CCache;
use COpts;

my $version = '1.1.0';

# --------- DEB -----------------
my $debug_vs = 0;
my $debug_prof = 0;
my $debug_rules = 0;
# --------- DEB -----------------

# -- hack needed to support F5 iCR API transactions
sub PATCH  { _simple_req('PATCH',  @_); }
# --

our ( %opts );
getopts('u:p:O:t:q:fdhAikKTrQc:C:I:sSx:R:w:l:b:Z:P:', \%opts);

unless ($opts{'Q'}) {
  print("(C) 2019, Krystian Baniak <krystian.baniak\@exios.pl>,  F5 restful configuration tool, version: $version\n");
}
#-------------------------------------------------
# advanced options parser
my $popts = COpts->new();
if ($opts{'O'}) {
  $popts->parse( $opts{'O'} );
  if ($popts->isFailed()){
    print "-- error in parsing options! Aborting ...\n";
    exit 3;
  }
}
#-------------------------------------------------
# help message
if ($opts{'h'}){
  my $__odefs = $popts->describe;
  my $__bdefs = $popts->batch_describe;
  print <<QQQ
--- [*] help section:

 invocation:
   $0 <options>

 options:
 --------------------------------------------------------------------------------------------

   -h           : this help message
   -d           : debug mode
   -q query     : single query mode, will not produce output file
   -u user      : user, default is admin
   -p password  : password, default is admin
   -f           : password will be read from the stdin after a prompt
   -t host      : f5 mgmt interface's IP address to query
   -A           : create archive containing iRules and iCall scripts
   -l name      : label used to create archive file name (affects -A option)
   -i           : identify f5 box
   -k           : verify iRule versions and allocation to virtual servers
   -K           : verify listeners and their allocation to virtual servers
   -c name      : create iRule or other resource from a file given in -I option
   -C name      : update iRule or other resource from a file given in -I option
   -I           : input resource
   -P           : port to connect to
   -r           : retain temporal objects (used with -A option)
   -s           : save config
   -S           : sync cluster
   -w           : working directory
   -b name      : batch mode that uses json file as input
   -Z step      : select step set from a step set list

   -x cmd       : execute advanced script action
   -R name      : run special report name [ availability depends on version ]
   -T           : use token based authentication
   -Q           : quiet mode - supress logs to a file
   -O opts      : list of options param=value,param=value, use %20 to escape a white space
                  example:  base=gen8.2/test,label=ala%20ma%20kota

 --------------------------------------------------------------------------------------------

 list of known options:
$__odefs

 list of known batch commands
$__bdefs

--- *
QQQ
  ;
  exit;
}

STDOUT->autoflush(1);

# -- Orange F5 nodes
my %nodes = %{ load_dataset_from_file('./cfg/nodes.json', 'nodes') };
my %props = ();
my %srun = ();
# ----------------- SETTINGS --------------------
my $usr   = $opts{'u'} || 'admin';
my $pass  = $opts{'p'} || 'admin';
my $host  = $opts{'t'} || '192.168.1.254';
my $ifns  = $opts{'I'} || 'input.txt';
my $wDir  = $opts{'w'} || '';
my $Label = $opts{'l'} || '';
my $bstep = $opts{'Z'} || '';
my $cport = $opts{'P'} || 443;
my $URL_BARE = "https://$host/";
my $URL   = "https://$host/mgmt/tm/";
my $URLB  = "https://$host/mgmt/shared/authn/login";
my $host_name = $host;
my $tmp_stmp = &gen_tmstmp;
my %ems;
my $tks = '';
if ($opts{'P'}) {
  $URL_BARE = "https://$host:$opts{'P'}/";
  $URL   = "https://$host:$opts{'P'}/mgmt/tm/";
  $URLB  = "https://$host:$opts{'P'}/mgmt/shared/authn/login";
}
#-------------------------------------------------
# Authentication Cache
my $cache = CCache->new("./cfg/.ccache.json");
unless (-e "./cfg/.ccache.json") {
  print "-- creating new empty cache file.\n";
  $cache->setup_authcache( \%nodes );
  $cache->save;
}
$cache->open;
# interactive password retrieval
if ($opts{'f'}) {
  $pass = $cache->getUserCredentials;
}
#-------------------------------------------------
# Log file settings
# by default we make a transation log fom every script invocation
# the results are kept in the logfiles directory
unless (-e "logfiles" && -d "logfiles") {
  mkdir "logfiles";
}
my $log_fname = "logfiles/config-audit-log-${tmp_stmp}.log";
if ($popts->get('onelog') eq "yes") {
  $log_fname = "logfiles/config-audit-log.log";
}
my $tee = \*STDOUT;
if ($opts{'Q'} or ($popts->get('supress_log') eq "yes")) {
  #print "+ supressing transactional logging...\n";
} else {
  $tee = new IO::Tee(\*STDOUT, new IO::File(">$log_fname"));
}
#-------------------------------------------------
# determine host and authentication details
update_host( $host );
#-------------------------------------------------
# working directory settings
my $remove_temp = 1;
if ($opts{'r'}) { $remove_temp = 0; }
if ($wDir ne '') {
  if (! -e $wDir) {
    printf $tee "!-- working directory not found: $wDir\n";
    exit;
  }
} else {
  $wDir = $rundir;
}
# -----------------------------------------------
# Debug settings
my $db_cr = 0;
if ($opts{'d'}){
  # enable all kinds of debug messages
  $debug_vs = $debug_prof = 1;
  $db_cr = 1;
}
#------------------------------------------------
# LWP settings
my $ua   = new LWP::UserAgent;
$ua->timeout(20);
$ua->ssl_opts( verify_hostname => 0, SSL_verify_mode => 0x00 );
#------------------------------------------------
# F5 token based authentication
if ($opts{'T'}) {
  $tks = &tokenRequest;
  #print Dumper($tks);
  if ($tks->{token}) {
    $tks = $tks->{token}{token};
    print "++ token: $tks\n";
  }
}
#-----------------------------------------------
# Properties are needed for Batch mode
if ($popts->get('bigiq') ne '') {

} else {
  # get big-ip properties
  &update_platform_properties;
  if ($opts{'i'}){
    &print_platform_properties;
  }
}
#-----------------------------------------------
# batch mode
if ($opts{'b'}) {
  print $tee "+ running in a batch mode\n";
  print $tee "+-- input file: $opts{'b'}\n";
  batch_mode( $opts{'b'} );
  exit;
}

# single query mode
if ($opts{'q'}) {
 print $tee "received query: $opts{'q'}\n";
 my $p = $opts{'q'};
 if ($p and $p ne '-') {
   my $curl = $URL;
   if ($popts->get('bigiq') ne '') {
     $curl = $URL_BARE;
   }
   if ($popts->get('format') eq 'json') {
     print $tee query2json( $curl . $p );
   } else {
     print $tee Dumper( query2object( $curl . $p ));
   }
 }
 exit;
}
#------------------------------------------------
# cmd mode
if ($opts{'x'}) {
  my $data = runGenericCommand($opts{'x'});
  if ($popts->get("respOnly") ne "") {
    if (defined $data->{'commandResult'}) {
      print $tee $data->{'commandResult'};
    } else {
      print $tee "-- command failed. \n";
    }
  } else {
    print Dumper( $data );
  }
  exit;
}
#-----------------------------------------------
# Report mode
if ($opts{'R'}) {
  if ($opts{'i'}){
    &update_platform_properties;
    &print_platform_properties;
  }
  print $tee "+ running report: $opts{'R'} \n";
  my $tms = strftime("%a %d %b %H:%M:%S %Y", localtime);
  printf $tee "+ timestamp: %s\n", $tms;
  switch ($opts{'R'}) {
    case 'RULE' {
      &report_irules($popts->get('base'), $popts->get('diff'));
    }
    case 'ISTATS' {
      &report_istats_generic;
    }
    default {
      &run_custom_report($opts{'R'});
    }
  }
  exit;
}
#-----------------------------------------------
# create commands
if ($opts{'c'} or $opts{'C'}) {
  my $_t = 'rule';
  if ($popts->get('ctype') ne "") {
    $_t = $popts->get('ctype');
  }
  if ($opts{'c'}) {
    print $tee "+ creating resource of type: $_t: $opts{'c'}\n";
    createResource($_t, $opts{'c'}, 'Common', $ifns,'');
  } else {
    print $tee "+ updating resource of type: $_t: $opts{'C'}\n";
    updateResource($_t, $opts{'C'}, 'Common', $ifns);
  }
  exit;
}
#-----------------------------------------------
if ($opts{'k'}) {
  print $tee "+ analysing iRules and their alloactions ...\n";
  checkRules( 1 );
  exit;
}
#-----------------------------------------------
if ($opts{'K'}) {
  print $tee "+ analysing Listeners and their alloactions ...\n";
  &checkVirtuals;
  exit;
}
#-----------------------------------------------
if ($opts{'s'}) {
  print $tee "+ saving configuration ...\n";
  &saveRunConfig;
  exit;
}
#-----------------------------------------------
if ($opts{'S'}) {
  if (defined $props{'failover cluster'}) {
    print $tee "+ synchronizing configuration in the cluster: $props{'failover cluster'}...\n";
    syncCluster( $props{'failover cluster'} );
  }
  exit;
}
#-----------------------------------------------
# save iRules and iCall scripts into an archive
#
if ( $opts{'A'} ) {
  if ($wDir ne '') { printf $tee "++ using workdir: $wDir\n"; }
  my $d = "${host_name}_archive";
  if ($Label ne '') {
    $d = "${Label}_archive_${host_name}_${tmp_stmp}";
  }
  print "++ creating databook archive: $d\n";
  mkdir $d;
  mkdir "$d/iRules";
  my $rules = query2object( $URL . 'ltm/rule');
  if ($debug_rules) { print Dumper($rules); }
  foreach my $r ( @{ $rules->{'items'} }) {
    next if ($r->{'name'} =~ /^_sys_/);
    print $tee "dumping iRule: $r->{'name'}, partition: $r->{'partition'}\n";
    unless (-e "$d/iRules/$r->{'partition'}"){
      mkdir "$d/iRules/$r->{'partition'}";
    }
    open my $fh, ">", "$d/iRules/$r->{'partition'}/$r->{'name'}.tcl" or die "--- Error: Cannot create iRule file!\n";
    print $fh $r->{'apiAnonymous'};
    close($fh);
  }

  mkdir "$d/Scripts";
  my $scr = query2object( $URL . 'cli/script' );
  foreach my $r ( @{ $scr->{'items'} } ) {
    print $tee "dumping cli script: $r->{'name'}, partition: $r->{'partition'}\n";
    unless (-e "$d/Scripts/$r->{'partition'}"){
      mkdir "$d/Scripts/$r->{'partition'}";
    }
    open my $fh, ">", "$d/Scripts/$r->{'partition'}/$r->{'name'}.tcl" or die "--- Error: Cannot create iRule file!\n";
    print $fh $r->{'apiAnonymous'};
    close($fh);
  }

  my $dg = query2object( $URL . 'ltm/data-group/internal');
  my $js = JSON->new;
  $js->pretty();
  open my $fh, ">", "$d/data-groups-internal.json" or die "--- Error: Cannot create dg file!\n";
  foreach my $r ( @{ $dg->{'items'} }) {
    print $fh $js->encode($r);
  }
  close($fh);

  if ($^O eq "MSWin32") {
    `tar -cf $rundir/$wDir/$d.tar $d/`;
  } else {
    `tar -cf $rundir/$wDir/$d.tar $d/`;
  }
  if ($remove_temp) {
    print $tee "... trying to remove directory";
    remove_tree("$d");
  }
}
print $tee "+++ job's done.";
exit;

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# Routines

#
# load config from a file with json encoding
sub load_dataset_from_file
{
  my ($fname, $type) = @_;
  open my $fh, "<", "$fname" or die "--- Error opening resource file: $fname!\n";
  read $fh, my $buffer, -s $fh;
  close $fh;
  my $k = decode_json( $buffer );
  if (defined($k->{$type})) {
    return $k->{$type};
  } else {
    return undef;
  }
}

# update platform structures
sub update_platform_properties {
  %props = &get_propsy;
  %srun  = &get_running_software;
}
# print information about F5 device (or a cluster node)
sub print_platform_properties {
  print $tee "system properties: \n";
  foreach my $k (sort keys %props){
    printf $tee "  %40s: %s\n", $k, $props{$k};
  }
  foreach my $k (sort keys %srun){
    printf $tee "  %40s: %s\n", $k, $srun{$k};
  }
}
#
# update host structures
sub update_host {
  my $_h = shift;

  if ($_h =~ /^[a-zA-Z]/){
    $host_name = $_h;
    if (defined( $nodes{ $_h } )){
      $host = $nodes{ $_h };
      $URL_BARE = "https://$host/";
      $URL = "https://$host/mgmt/tm/";
      $URLB = "https://$host/mgmt/shared/authn/login";
      unless ($opts{'Q'}) { print $tee "+ host $host_name mapped to: [ $host ]\n"; }
    } else {
      print $tee "--- unknown host given!\n";
      exit;
    }
  }
  my ($_u,$_p) = $cache->check_auth( $_h );
  if (($_u ne 'x') and ($_u ne $usr)) { $usr = $_u; }
  if (($_p ne 'x') and ($_p ne $pass)) { $pass = $_p; }
}
#
# generate timestamp
sub gen_tmstmp {
  my $ss = strftime "%d%m%y-%H%M%S", localtime;
  return $ss;
}

#
# get system properties
sub get_propsy {
  my %p;
  my $r = query2object( $URL . 'sys/hardware');
  $p{'marketingName'} = $r->{'entries'}{'https://localhost/mgmt/tm/sys/hardware/platform'}{'nestedStats'}{'entries'}{'https://localhost/mgmt/tm/sys/hardware/platform/0'}{'nestedStats'}{'entries'}{'marketingName'}{'description'};
  $p{'baseMac'} = $r->{'entries'}{'https://localhost/mgmt/tm/sys/hardware/platform'}{'nestedStats'}{'entries'}{'https://localhost/mgmt/tm/sys/hardware/platform/0'}{'nestedStats'}{'entries'}{'baseMac'}{'description'};
  $p{'bigipChassisSerialNum'} = $r->{'entries'}{'https://localhost/mgmt/tm/sys/hardware/system-info'}{'nestedStats'}{'entries'}{'https://localhost/mgmt/tm/sys/hardware/system-info/0'}{'nestedStats'}{'entries'}{'bigipChassisSerialNum'}{'description'};
  $p{'platform'} = $r->{'entries'}{'https://localhost/mgmt/tm/sys/hardware/system-info'}{'nestedStats'}{'entries'}{'https://localhost/mgmt/tm/sys/hardware/system-info/0'}{'nestedStats'}{'entries'}{'platform'}{'description'};
  $r = query2object( $URL . 'cm/device-group');
  foreach my $e ( @{ $r->{'items'} }) {
    if ($e->{'type'} eq 'sync-failover') {
      $p{'failover cluster'} = $e->{'name'};
    }
  }
  $r = query2object( $URL . 'cm/device' );
  $p{'fovState'} = 'passive';
  foreach my $e ( @{ $r->{'items'}} ) {
    if ($e->{'managementIp'} eq $host) {
      if ($e->{'failoverState'} eq 'active'){
        $p{'fovState'} = 'active';
      }
    }
  }
  return %p;
}

#
# query 2 JSON
sub query2json
{
  my $uri = shift;
  my $mode = shift || 'no';
  if ($mode eq 'yes') {
    $uri =~ s/localhost/$host/;
  }
  if ($opts{'P'}){
    if ($uri =~ /^https:\/\/([^\/:]+)\/(.+)$/) {
      $uri = "https://$1:$opts{'P'}/$2";
      print ". modif --> $uri\n";
    }
  }
  my $r = GET $uri;
  if ($opts{'T'}){
    $r = GET $uri, 'X-F5-Auth-Token' => $tks;
  } else {
    $r->authorization_basic($usr, $pass);
  }
  my $res = $ua->request( $r );
  my $cd = $res->code;
  my $resp = $res->content;

  my $js = JSON->new;
  $js->pretty;

  if ($cd ne 200) {
    if (($cd eq 404) && ($resp =~ /was not found/)){
      return $js->encode( { error => 'not found' } );
    } else {
      print $tee "--- http get req error, code: $cd\n";
      print $tee "--- response: $resp\n";
      exit;
    }
  }

  # we get final response
  if ($popts->get('save_query_result') eq 'yes') {
    if (! -e "$wDir/.creq-cache") {
      print $tee "- creating json cache dir: $wDir/.creq-cache\n";
      mkdir "$wDir/.creq-cache";
    }
    my $curi;
    if ($uri =~ /^https:\/\/.+\/mgmt\/tm\/(.+)$/) {
      $curi = $1;
      $curi =~ s/\?.*//;
      $curi = join('-', split('/', $curi));
      my $lcfile = "$wDir/.creq-cache/$host-$curi-$tmp_stmp.json";

      open my $fh, ">", $lcfile or die "--- Error creating json file: $lcfile!\n";
      print $fh $res->content;
      close $fh;
    }
  }

  # return results
  return $js->encode( $js->decode($res->content) );
}
#
# query 2 perl object
sub query2object
{
  my $uri = shift;
  my $mode = shift || 'no';
  return decode_json( query2json( $uri, $mode ) );
}

sub tokenRequest
{
  my $js = JSON->new;
  my $z = {
    username           => $usr,
    password           => $pass,
    loginProviderName  => 'tmos',
  };
  $js->pretty();

  my $r = POST $URLB, 'Content-Type' => 'application/json', 'Content' => $js->encode( $z );
  $r->authorization_basic($usr, $pass);
  my $res = $ua->request( $r );
  my $cd = $res->code;
  my $resp = $res->content;

  if ($cd ne 200) {
    print $tee "--- http post req error, code: $cd\n";
    print $tee "--- response: $resp\n";
    exit;
  }

  return decode_json($res->content);
}

sub rawRequest
{
  my ($method, $uri, $js) = @_;
  my $r;
  switch ($method) {
    case 'POST' {
      $r = POST $uri, 'Content-Type' => 'application/json', 'Content' => $js;
    }
  };
  $r->authorization_basic($usr, $pass);
  return $ua->request( $r );
}

sub postRequest
{
  my $u = shift;
  my $js = shift;
  my $deb = shift || 'no';
  my $r = POST $u, 'Content-Type' => 'application/json', 'Content' => $js;
  $r->authorization_basic($usr, $pass);
  my $res = $ua->request( $r );
  my $cd = $res->code;
  my $resp = $res->content;

  if ($deb eq 'yes') {
    print $tee "--- response: $resp\n";
  }

  if ($cd ne 200) {
    print $tee "--- http post req error, code: $cd\n";
    print $tee "--- response: $resp\n";
    exit;
  }

  return decode_json($res->content);
}

sub putRequest
{
  my $u = shift;
  my $js = shift;
  my $r = PUT $u, 'Content-Type' => 'application/json', 'Content' => $js;
  $r->authorization_basic($usr, $pass);
  my $res = $ua->request( $r );
  my $cd = $res->code;
  my $resp = $res->content;

  if ($cd ne 200) {
    print $tee "--- http put req error, code: $cd\n";
    print $tee "--- response: $resp\n";
    exit;
  }

  return decode_json($res->content);
}

sub patchRequest
{
  my $u = shift;
  my $js = shift;
  my $r = HTTP::Request->new(PATCH => $u);
  $r->header( 'Content-Type' => 'application/json' );
  $r->content( $js );
  $r->authorization_basic($usr, $pass);
  my $res = $ua->request( $r );
  my $cd = $res->code;
  my $resp = $res->content;

  if ($cd ne 200) {
    print $tee "--- http patch req error, code: $cd\n";
    print $tee "--- response: $resp\n";
    exit;
  }
  return decode_json($res->content);
}

sub deleteRequest
{
  my $u = shift;
  my $r = HTTP::Request->new(DELETE => $u);
  $r->authorization_basic($usr, $pass);
  my $res = $ua->request( $r );
  my $cd = $res->code;
  my $resp = $res->content;

  if ($cd ne 200) {
    if (($cd eq 404) && ($resp =~ /was not found/)){
      return 2;
    } else {
      print $tee "--- http delete req error, code: $cd\n";
      print $tee "--- response: $resp\n";
      exit;
    }
  }
  return 0
}
#
# Converts Object to string
#
sub obj2str
{
  my $obj = shift;
  my $ret = "-";

  if (not defined($obj) or $obj eq '') {
    return $ret;
  }

  if (ref $obj eq 'ARRAY'){
    $ret = join("\n", map { &obj2str($_) } @{ $obj });
  } elsif (ref $obj eq 'HASH'){
    my @a = qw( { );
    foreach my $i (sort keys %{ $obj }){
      # filter common not displayable properties
      unless ($i =~ /^(selfLink|kind|fullPath|generation)$/) {
        push @a, $i . ": " . &obj2str( $obj->{$i} );
      }
    }
    push @a, '}';
    $ret = join("\n", @a);
  } else {
    $ret = $obj;
    $ret =~ tr/[\n\r]//;
  }

  return $ret;
}
#
# Convert array of Objects to a string
#
sub objectarray2string
{
  my $a = shift;
  my @ret;
  foreach my $it ( @{ $a } ){
    my @hh = qw( { );
    foreach my $_t (sort keys %{ $it }) {
      unless ($_t =~ /^(selfLink|kind|fullPath|generation)$/) {
          push @hh, $_t . ': ' . $it->{ $_t };
      }
    }
    push @hh, '}';
    push @ret, join( "\n", @hh);
  }
  return join( "\n", @ret );
}

#
# follow references and expand them by converting into objects
#
sub checkReference
{
  my $r  = shift;
  my $ar = [];

  if ($db_cr) { print " debug: checkReference\n"; }
  foreach my $e ( @{ $$r->{'items'} }){
    my $z = {};
    foreach my $p (keys %{ $e } ) {
      if ($p =~ /^(.+)Reference$/){
        my $ct = ref $e->{$p};
        # print "checkReference:  $ct: $p\n";
        #
        # since version 12.0 additional references are included in ARRAY for given property such as iRule, vlan, profile
        #
        if ($ct eq 'HASH') {
          my $qe = query2object( $e->{$p}{'link'}, 'yes');
          #$z->{$p} = objectarray2string( $qe->{'items'} );
          $z->{$p} = $qe->{'items'};
        }
      } else {
        $z->{$p} = $e->{$p};
      }
    }
    push @{ $ar }, $z;
  }
  $$r->{'items'} = $ar;
}

#
# same as above but for flat type of collections
#
sub checkReferenceFlat
{
  my $r  = shift;
  my $z = {};

  if ($db_cr) { print " debug: checkReferenceFlat\n"; }
  foreach my $p (keys %{ $$r } ){
    if ($p =~ /^(.+)Reference$/){
      my $ct = ref $$r->{$p};
      #print " cRF: $p : $ct";
      if ($ct eq 'HASH') {
        my $qe = query2object( $$r->{$p}{'link'}, 'yes');
        $z->{$p} = objectarray2string( $qe->{'items'} );
      }
    } else {
      $z->{$p} = $$r->{$p};
    }
  }
  $$r = $z;
}

sub dumpObject2Array {
  my $obj = shift;
  my $hea = shift || 0;
  my @a = qw( name );

  if ( ref $obj eq 'HASH' ){
    foreach my $e (sort keys %{ $obj }) {
      unless ($e =~ /^(selfLink|kind|name|fullPath|generation)$/) {
        push @a, $e;
      }
    }
    if ($hea) {
      return @a;
    } else {
      return map { if ($_ eq 'name'){ $obj->{'name'} } else { obj2str( $obj->{$_} ) } } @a;
    }
  }
  return @a;
}

#
# analyze virtual servers
#
sub checkVirtuals {
  my $vs = query2object( $URL . 'ltm/virtual' );
  printf $tee "\n %40s | %9s | %14s | %9s | %-40s\n",'name','partition','folder','type','vlan';
  printf $tee "%s\n", '-' x 110;
  foreach my $r ( @{ $vs->{'items'} } ) {
    my $v = $r->{'vlans'};
    if ( ref $v eq 'ARRAY' ){
      $v = join ', ', @{ $v };
    } else {
      $v = "-empty-";
    }
    my $subp = '';
    if (defined($r->{'subPath'})) {
      $subp = $r->{'subPath'};
    }
    printf $tee " %40s | %9s | %14s | %9s | %-40s\n", $r->{'name'}, $r->{'partition'}, $subp, $r->{'ipProtocol'}, $v;
  }
  printf $tee "%s\n", '-' x 110;
}

#
# analyze iRules
# returns a hash with irule_name as a key and props:
# - used      : 1|0
# - modified  : 1|0
# - hash      : sha1 of iRule code
# - partition
sub checkRules {
  my $rules = query2object( $URL . 'ltm/rule');
  if ($debug_rules) { print Dumper($rules); }
  my %RR = qw();
  my $verb = shift || 0;
  my %irules = qw();

  if ($verb) {
    printf $tee "\n %42s | %8s | %-40s\n",'name','partition','hash';
    printf $tee "%s\n", '-' x 98;
  }
  foreach my $r ( @{ $rules->{'items'} }) {
    next if ($r->{'name'} =~ /^_sys_/);
    my $dg = sha1_hex( $r->{'apiAnonymous'} || '' );
    my $key = "/" . $r->{'partition'} . "/" . $r->{'name'};
    if ($verb) { printf $tee " %42s | %8s | %40s\n", $r->{'name'}, $r->{'partition'}, $dg; }
    $RR{ $key } = 0;
    $irules{$r->{'name'}} = {
       hash      => $dg,
       used      => 0,
       partition => $r->{'partition'},
    };
  }

  my $vss = query2object( $URL . 'ltm/virtual');
  if ($verb) {
    printf $tee "%s\n", '-' x 160;
    printf $tee "\n %32s | %12s | %32s | %-40s\n",'name','partition','application service','list of numbered iRules';
    printf $tee "%s\n", '-' x 160;
  }
  foreach my $r ( @{ $vss->{'items'}}) {
    my $rl = '';
    my $aps = $r->{'appService'} || '-';
    $aps =~ s/\/Common\///;
    if (defined $r->{'rules'}) {
      my $fo = 0;
      foreach my $k ( @{ $r->{'rules'}} ) {
        if (defined $RR{$k} ) {
          $RR{$k} = 1;
          $irules{$k}{used} = 1;
        }
        if ($fo == 0){
          $fo++;
          if ($verb) { printf $tee " %32s | %12s | %32s | [%2d]  %-40s\n", $r->{'name'}, $r->{'partition'}, $aps, $fo, $k; }
        } else {
          $fo++;
          if ($verb) { printf $tee " %32s | %12s | %32s | [%2d]  %-40s\n", ' ', ' ', ' ', $fo, $k; }
        }
      }
    } else {
      if ($verb) { printf $tee " %32s | %12s | %32s | %40s\n", $r->{'name'}, $r->{'partition'}, $aps, $rl; }
    }
  }
  if ($verb) {
    printf $tee "%s\n", '-' x 160;
    print $tee "\n+ unused iRules:\n";
    printf $tee "%s\n", '-' x 160;
    foreach my $k ( sort keys %RR ) {
      if ($RR{ $k } == 0) { print $tee "$k\n"; }
    }
    printf $tee "%s\n", '-' x 160;
  }
  return %irules;
}

sub saveRunConfig
{
  my $js = JSON->new;
  my $z = {
    command => "save",
  };
  $js->pretty();
  return postRequest( $URL . 'sys/config', $js->encode( $z ), 'no' );
}

sub syncCluster
{
  my $grp = shift;
  my $js = JSON->new;
  my $z = {
    command     => "run",
    utilCmdArgs => "config-sync to-group $grp",
  };
  $js->pretty();
  return postRequest( $URL . 'cm', $js->encode( $z ), 'yes' );
}

sub runGenericCommand
{
  my $cmd = shift;
  my $js = JSON->new;
  my $z = {
    command     => "run",
    utilCmdArgs => " -c '$cmd'",
  };
  $js->pretty();
  return postRequest( $URL . 'util/bash', $js->encode( $z ) );
}

sub loadMergeFile
{
  my $fle = shift;
  my $js = JSON->new;
  my $z = {
    command     => "load",
    utilCmdArgs => "merge file $fle",
  };
  $js->pretty();
  return postRequest( $URL . 'sys/config', $js->encode( $z ) );
}

sub verifyMergeFile
{
  my $fle = shift;
  my $js = JSON->new;
  my $z = {
    command     => "load",
    utilCmdArgs => "merge file $fle verify",
  };
  $js->pretty();
  my $r = rawRequest( 'POST', $URL . 'sys/config', $js->encode( $z ) );
  if ($r->code eq 200) {
    return 'OK';
  } else {
    my $m = decode_json( $r->content );
    return $m->{'message'};
  }
}

sub createResource
{
  my ($t, $n, $part, $r, $mds) = @_;
  my $js = JSON->new;
  $js->pretty();

  if ($t eq 'rule') {
    open my $fh, "<", "$r" or die "--- Error opening resource file: $r!\n";
    read $fh, my $buffer, -s $fh;
    close $fh;
    my $z = {
      name => $n,
      kind => 'tm:ltm:rule:rulestate',
      partition => $part,
      apiAnonymous => $buffer,
      fullPath => "/" . $part . "/" . $n,
    };
    return postRequest( $URL . 'ltm/rule/', $js->encode( $z ) );
  }

  if ($t eq 'ifile') {
    my $transname = "/shared/tmp/tmp-auto-$n-" . $tmp_stmp;
    my $k = new CAudit( $host, $usr, $pass, $cport );
    $k->uploadFile( undef, $r, $transname );

    my $r = runGenericCommand( "tmsh create sys file ifile /$part/$n source-path file://$transname" );
    if (defined( $r->{'commandResult'})) {
      print $tee "error while creating resource: " . $r->{'commandResult'};
      runGenericCommand( "rm $transname" );
      exit 1;
    }
    runGenericCommand( "rm $transname" );

    # create ltm link for an ifile
    my $z = {
      name      => $n,
      kind      => 'tm:ltm:ifile:ifilestate',
      partition => $part,
      fullPath  => "/$part/$n",
      fileName  => "/$part/$n"
    };
    my $ck = existsResource( "ltm/ifile/~$part~$n" );
    if ($ck) {
      return $ck;
    } else {
      return postRequest( $URL . 'ltm/ifile/', $js->encode( $z ) );
    }
  }

  if ($t eq 'dgroup') {
    my $transname = "/shared/tmp/tmp-auto-$n-" . $tmp_stmp;
    my $k = new CAudit( $host, $usr, $pass, $cport );
    $k->uploadFile( undef, $r, $transname );

    my $dgtype = "string";
    if ($mds eq "ip") { $dgtype = "ip"; }
    my $r = runGenericCommand( "tmsh create sys file data-group /$part/$n type $dgtype source-path file://$transname" );
    if (defined( $r->{'commandResult'})) {
      print $tee "error while creating resource: " . $r->{'commandResult'};
      runGenericCommand( "rm $transname" );
      exit 1;
    }
    runGenericCommand( "rm $transname" );

    # create ltm link for an data-group
    my $z = {
      name      => $n,
      kind      => 'tm:ltm:data-group:external:externalstate',
      partition => $part,
      externalFileName => "/$part/$n"
    };
    my $ck = existsResource( "ltm/data-group/external/~$part~$n" );
    if ($ck) {
      return $ck;
    } else {
      return postRequest( $URL . 'ltm/data-group/external', $js->encode( $z ) );
    }
  }

  if ($t eq 'monitor') {
    my $transname = "/shared/tmp/tmp-auto-$n-" . $tmp_stmp;
    my $k = new CAudit( $host, $usr, $pass );
    $k->uploadFile( undef, $r, $transname );

    my $r = runGenericCommand( "tmsh create sys file external-monitor /$part/$n source-path file://$transname" );
    if (defined( $r->{'commandResult'})) {
      print $tee "error while creating resource: " . $r->{'commandResult'};
      runGenericCommand( "rm $transname" );
      exit 1;
    }
    runGenericCommand( "rm $transname" );
  }

}

#
# check if given resource iCR path exists
# returns 0 or object
sub existsResource {
  my ($name) = @_;
  my $r = query2object( $URL . $name );
  if (defined $r->{'error'}){
    return 0;
  } else {
    return $r;
  }
}

#
# update resource: iRule|ifile,...
sub updateResource
{
  my ($t, $n, $part, $r) = @_;
  my $js = JSON->new;
  $js->pretty();

  if ($t eq 'rule') {
    open my $fh, "<", "$r" or die "--- Error opening resource file: $r!\n";
    read $fh, my $buffer, -s $fh;
    close $fh;
    my $z = {
      apiAnonymous => $buffer
    };
    return putRequest( $URL . 'ltm/rule/' . $n, $js->encode( $z ) );
  }

  if ($t eq 'ifile') {
    my $transname = "/shared/tmp/tmp-auto-$n-" . $tmp_stmp;
    my $k = new CAudit( $host, $usr, $pass, $cport );
    $k->uploadFile( undef, $r, $transname );

    my $r = runGenericCommand( "tmsh modify sys file ifile /$part/$n source-path file://$transname" );
    if (defined( $r->{'commandResult'})) {
      printf $tee "error while updating resource: %s \n", $r->{'commandResult'};
      runGenericCommand( "rm $transname" );
      exit 1;
    }
    runGenericCommand( "rm $transname" );

    unless ( existsResource( "ltm/ifile/~$part~$n" ) ) {
      print $tee "error ltm ifile missing!";
      return 0;
    }

  }

  if ($t eq 'dgroup') {
    my $transname = "/shared/tmp/tmp-auto-$n-" . $tmp_stmp;
    my $k = new CAudit( $host, $usr, $pass, $cport );
    $k->uploadFile( undef, $r, $transname );

    my $r = runGenericCommand( "tmsh modify sys file data-group /$part/$n source-path file://$transname" );
    if (defined( $r->{'commandResult'})) {
      print $tee "error while updating resource: " . $r->{'commandResult'};
      runGenericCommand( "rm $transname" );
      exit 1;
    }
    runGenericCommand( "rm $transname" );

    unless ( existsResource( "ltm/data-group/external/~$part~$n" ) ) {
      print $tee "error ltm dgroup external link is missing!";
      return 0;
    }
  }

  if ($t eq 'monitor') {
    my $transname = "/shared/tmp/tmp-auto-$n-" . $tmp_stmp;
    my $k = new CAudit( $host, $usr, $pass, $cport );
    $k->uploadFile( undef, $r, $transname );

    my $r = runGenericCommand( "tmsh modify sys file external-monitor /$part/$n source-path file://$transname" );
    if (defined( $r->{'commandResult'})) {
      print $tee "error while updating resource: " . $r->{'commandResult'};
      runGenericCommand( "rm $transname" );
      exit 1;
    }
    runGenericCommand( "rm $transname" );
  }

}

#
# delete resource
sub deleteResource {
  my ($t, $n) = @_;
}

#
# verify if specified resource exists in F5's configuration
sub check_icr_path {
  my ($def, $opts) = @_;
  my $ldir = './js-store'; # directory to save backups
  my $cdir = 'js-templates';
  if (defined($opts->{'make_local_copy'}) and $opts->{'make_local_copy'}) {
    print $tee "  . saving resources into js-store \n";
    if (defined $opts->{'js-store-dir'}) {
      substr($ldir, 0, 1) = $opts->{'js-store-dir'};
    } else {
      substr($ldir, 0, 1) = $wDir;
    }
    unless (-e $ldir) {
      print $tee "  . creating local store: $ldir\n";
      mkdir $ldir;
    }
  }
  if (defined($def->{'type'} and defined($def->{'set'}))) {
    print $tee '-'x 110 . "\n";
    print $tee "  . processing verify category: \x1b[34m$def->{'type'}\x1b[0m\n";
    for my $item (sort @{ $def->{'set'} }) {
      my $verd = "\x1b[31mMISS\x1b[0m";
      my $extra = '';
      my $pa = "Common";
      if (defined($item->{'partition'})) {
        $pa = $item->{'partition'};
      }
      if (defined($item->{'app'})) {
        $pa .= "~$item->{'app'}";
      }
      my $r = existsResource( "$def->{'type'}/~$pa~$item->{'name'}" );
      if ($r) {
        $verd = "\x1b[32mFOUND\x1b[0m";
        if (defined($opts->{'make_local_copy'}) and $opts->{'make_local_copy'}) {
          # save resource
          if (defined $r->{'apiAnonymous'}) {
            open my $fh, ">", "$ldir/$pa" . "~$item->{'name'}" or die "--- Error: Cannot create resource dump file!\n";
            print $fh $r->{'apiAnonymous'};
            close($fh);
          } else {
            my $js = JSON->new;
            $js->pretty();
            $js->canonical();
            foreach my $z ( qw( defaultsFromReference generation kind selfLink appServiceReference) ) {
              delete $r->{$z};
            }
            my $data = $js->encode($r);
            open my $fh, ">", "$ldir/$pa" . "~$item->{'name'}" or die "--- Error: Cannot create resource dump file!\n";
            print $fh $data;
            close($fh);
          }
        }
        if (defined($opts->{"base_location"})) {
          if (defined $opts->{'js-template-dir'}) {
            $cdir = $opts->{'js-template-dir'};
          }
          my $localFile = $opts->{"base_location"} . "/" . "$cdir/$pa~" . $item->{'name'};
          if (-e $localFile) {
            # if template exists than compare
            my $l_ssha = get_file_sha1( $localFile, '' );
            my $buffer = '';
            if (defined $r->{'apiAnonymous'}) {
              $buffer = $r->{'apiAnonymous'};
            } else {
              my $js = JSON->new;
              $js->pretty();
              $js->canonical();
              foreach my $z ( qw( defaultsFromReference generation kind selfLink appServiceReference) ) { delete $r->{$z}; }
              $buffer = $js->encode($r);
            }
            my $r_ssha = sha1_hex( $buffer );
            if ($r_ssha eq $l_ssha) {
              $extra = "(verification::positive hash:$r_ssha)";
            } else {
              $extra = "(verification::failed hash local:$l_ssha remote:$r_ssha)";
              if (defined $opts->{'verify_diff'} and $opts->{'verify_diff'}) {
                my $fsd = get_file_content( $localFile );
                my $df = diff \$buffer, \$fsd, { STYLE => "Unified" };
                my @lines = split /[\n]/, $df;
                foreach my $l (@lines) {
                  if ($l =~ /^\-/) {
                    print $tee $l . "\n";
                  } elsif ($l =~ /^\@\@/) {
                    if ($^O eq "MSWin32") {
                      printf $tee "%s\n", $l;
                    } else {
                      printf $tee "\033[35m%s\033[0m\n", $l;
                    }
                  } else {
                    if ($^O eq "MSWin32") {
                      printf $tee "%s\n", $l;
                    } else {
                      printf $tee "\033[33m%s\033[0m\n", $l;
                    }
                  }
                }
              }
            }
          } else {
             printf ">>> not found: lc: %s \n", $localFile;
          }
        }
      }
      if (defined($item->{'app'})) {
        printf $tee "  %-32s: [%s] %s\n", "$item->{'app'}/$item->{'name'}", $verd, $extra;
      } else {
        printf $tee "  %-32s: [%s] %s\n", $item->{'name'}, $verd, $extra;
      }
    }
    print $tee '-'x 110 . "\n";
  } else {
    print $tee "error while processing verification set: ";
    exit 1;
  }
}

sub get_running_software
{
  my %p;
  my $r = query2object( $URL . 'sys/software/volume');
  foreach my $r ( @{ $r->{'items'} } ) {
    if ($r->{'active'}) {
      $p{'active volume'}  = $r->{'name'};
      $p{'soft version'} = $r->{'version'};
      $p{'soft build'}   = $r->{'build'};
    }
  }
  return %p;
}

sub getCwd {
  my $ret;
  if ($^O eq "MSWin32") {
    $ret = `cd`;
  } else {
    $ret = `pwd`;
  }
  chomp($ret);
  return $ret;
}

sub batch_mode {
  my $fn = shift;

  if (index($fn, "/") < 0 or substr($fn,0,2) eq "./") {
    # try local directory as path is not absolute
    $fn = "$rundir/$fn";
  }

  open my $fh, "<", "$fn" or die "--- Error opening resource file: $fn!\n";
  read $fh, my $buffer, -s $fh;
  close $fh;

  my $confNo  = 0;
  my $tmsh_mg = 0;
  my $file_mg = 0;
  my $cmd_mg = 0;
  my $j = decode_json($buffer);

  # this is for extended tests
  $j->{'options'}{'rundir'} = $rundir;

  # options parsing
  if (defined $j->{'options'}{'working-directory'}) {
    $wDir = $j->{'options'}{'working-directory'};
    if ($wDir eq '') {
      # we cannot continue at that moment
      die "-f- working directory is empty!"
    }
    if (substr($wDir, 0, 2) eq "./") {
      $wDir = $rundir . "/";
      substr($wDir, 0, 1) = $rundir;
    }
    $wDir .= '/';
  }

  # base location fixup for relative paths
  if (defined $j->{'options'}{'base_location'}) {
    if (substr($j->{'options'}{'base_location'}, 0, 2) eq "./") {
      substr($j->{'options'}{'base_location'}, 0, 1) = $rundir;
    }
  }

  # iRules location pathing
  if (defined $j->{'options'}{'rules_location'}) {
    if (substr($j->{'options'}{'rules_location'}, 0, 2) eq "./") {
      substr($j->{'options'}{'rules_location'}, 0, 1) = $rundir;
    }
  }

  #verify system matches description
  if (defined ($j->{'system-ip'}) and ($j->{'system-ip'} ne "*")) {
    if ($host !~ /$j->{'system-ip'}/) {
      print $tee "(error) management IP address does not match\n";
      return;
    }
  }
  my $rsw = $srun{'soft version'} . "." . $srun{'soft build'};
  if (defined ($j->{'sw-version'}) and ($j->{'sw-version'} ne "*")) {
    if ($rsw !~ /$j->{'sw-version'}/) {
      print $tee "(error) running software: $rsw does not match requested: $j->{'sw-version'}\n";
      return;
    }
  }
  #print  Dumper( $j );

  if (defined $j->{'description'}) {
    printf $tee "<batch version=\"%s\" author=\"%s\">\n", $j->{'version'}, $j->{'author'};
    print  $tee "  batch provided for: $j->{'system'}\n";
    print  $tee "  description: $j->{'description'}\n";
    print  $tee "<\\batch>\n";
  }

  my $pxstep = $j->{'steps'};
  if (($bstep ne "") and (defined $j->{'stepset'})) {
    if (defined $j->{'stepset'}{$bstep}) {
      print $tee "+-- loading step set: $bstep\n";
      $pxstep = $j->{'stepset'}{$bstep};
    } else {
      print $tee "-- failed to find a step set: $bstep\n";
    }
  }

  foreach my $step ( @{ $pxstep } ) {
    # special targets
    my @otgt = split( ':', $step);
    my $cindex = 0;
    my $cabrt = 1;
    if ($#otgt == 1) {
      switch ($otgt[0]) {
        case 'DELAY' {
          sleep($otgt[1]);
        }
        case 'UPSET' {
          if ((defined $j->{'uploadset'}) && (defined $j->{'uploadset'}{$otgt[1]})) {
            foreach my $kx ( @{ $j->{'uploadset'}{$otgt[1]} }) {
              my $ksrc;
              if (index($kx,'|')>=0) {
                my @at = split('|', $kx);
                $kx = $at[0];
                $ksrc = $at[1];
              } else {
                $ksrc = parseFileToken($kx);
              }
              print $tee "+-- [step: $step] uploading object: $kx from $ksrc\n";
              if (defined $j->{'options'}{'base_location'}){
                my $k = new CAudit( $host, $usr, $pass, $cport );
                $k->uploadFile( $j->{'options'}, $ksrc, $kx );
              }
            }
          }
        }
        case 'CSET' {
          print $tee "+-- [step: $otgt[0] command set execute: $otgt[1]\n";
          if ((defined $j->{'commandset'}) && (defined $j->{'commandset'}{$otgt[1]})) {
            foreach my $kx ( @{ $j->{'commandset'}{$otgt[1]} }) {
              print $tee "   . executing command: $kx\n";
              my $r = runGenericCommand( $kx );
              if (defined $r->{'commandResult'}){
                printf $tee "  . (!!) unexpected command result: %s", $r->{'commandResult'};
              }
            }
          }
        }
        case 'RSET' {
          print $tee "+-- [step: $step] updating a set of irules: $otgt[1]\n";
          if ((defined $j->{'ruleset'}) && (defined $j->{'ruleset'}{$otgt[1]})) {
            load_irules( $j, $otgt[1] );
          }
        }
        case 'MSET' {
          print $tee "+-- [step: $step] merging tmsh config file set: $otgt[1]\n";
          if ((defined $j->{'mergeset'}) && (defined $j->{'mergeset'}{$otgt[1]})) {
            foreach my $kx ( @{ $j->{'mergeset'}{$otgt[1]} }) {
              if (defined $j->{'options'}{'base_location'}) {
                print $tee "  . \x1b[34mmerging file: $kx\x1b[0m\n";
                my $k = new CAudit( $host, $usr, $pass, $cport );
                $k->uploadFile( $j->{'options'}, parseFileToken($kx), $kx );
              }
              if (defined($j->{'options'}{'verify_merge_sets'})) {
                my $r = verifyMergeFile( $kx );
                if ($r ne 'OK') {
                  printf $tee "-- merge stopped due to a verification failure: \033[31m%s\033[0m\n", $r;
                  exit 1;
                } else {
                  loadMergeFile( $kx );
                }
              } else {
                loadMergeFile( $kx );
              }
            }
          }
        }
        case 'VERIFY_SET' {
          print $tee "+-- [step: $step] processing verification set: $otgt[1]\n";
          if ((defined $j->{'verifyset'}) && (defined $j->{'verifyset'}{$otgt[1]})) {
            foreach my $kx ( @{ $j->{'verifyset'}{$otgt[1]} }) {
              # kx is an object: type - icr path,  set - list of items to check
              check_icr_path( $kx, $j->{'options'} );
            }
          }
        }
        default {
          $cabrt = 0;
        }
      }
      next if $cabrt;
    }
    # normal targets
    switch ($step) {
      case 'COMPARE_DBSET' {
        print $tee "+-- [step: $step] comparing sys variables\n";
        report_dbvars( $j->{'dbvars'} );
      }
      case 'COMPARE_RULES' {
        print $tee "+-- [step: $step] comparing irule codebase\n";
        report_irules($j->{'options'}{'rules_location'}, ($j->{'options'}{'irule_diff'}) ? 'true' : 'false', $j);
      }
      case 'MAKE_UCS' {
        # Note: since 12.1.0 you need to perform all operations using iControl or iControlREST
        # ucs files created via REST is not available to iControl
        print $tee "+-- [step: $step] make system archive\n";
         #my $js = JSON->new;
         my $z = {
           command => "save",
           name => "migrate-auto-${host_name}-${tmp_stmp}"
         };
         if (defined $j->{'options'}{'ucs-file-name'}) {
           $z->{'name'} = $j->{'options'}{'ucs-file-name'} . "-" . ${tmp_stmp};
           print $tee "+-- setting ucs name to: $z->{'name'}";
         }
         #$js->pretty();
         #postRequest( $URL . 'sys/ucs', $js->encode( $z ) );
         my $k = new CAudit( $host, $usr, $pass, $cport );
         $k->createUcs( $z->{name} );
         print $tee "  . ucs saved into: $z->{name}\n";

         if ($wDir ne '') {
            $k->downloadResource('ucs', $z->{name} . ".ucs", $wDir . $z->{name} . ".ucs" );
         } else {
           print $tee "+-- note: working dir is not set, we do not download ucs!\n";
         }
         if ((defined $j->{'options'}{'remove_created_ucs'}) &&
             ($j->{'options'}{'remove_created_ucs'} eq 'yes')){
           # cleanup
           print $tee "  . removing ucs we have created\n";
           $k->deleteResource( $z->{name}, 'ucs' );
           #runGenericCommand( "tmsh delete sys ucs $z->{name}");
         }
      }
      case 'MAKE_SCF' {
        print $tee "+-- [step: $step] make system scf archive\n";
         my $js = JSON->new;
         my $fname = "migrate-auto-${host_name}-${tmp_stmp}.scf";
         my $z = {
           command => "save",
           options => [
             {
               file            => $fname,
               "no-passphrase" => ""
             }
           ]
         };

         $js->pretty();
         my $res = postRequest( $URL . 'sys/config', $js->encode( $z ) );
         print $tee ":: saving files to: $wDir\n";

         my $k = new CAudit( $host, $usr, $pass, $cport );
         if ($wDir ne '') {
            $k->downloadResource('file', "/var/local/scf/" . $fname, $wDir . $fname );
            $k->downloadResource('file', "/var/local/scf/" . $fname . ".tar", $wDir . $fname . ".tar" );
         } else {
           print $tee "+-- note: working dir is not set, we do not download scf!\n";
         }
         if ((defined $j->{'options'}{'remove_created_ucs'}) && ($j->{'options'}{'remove_created_ucs'} eq 'yes')){
           # cleanup
           print $tee "  . removing scf files we have created\n";
           $k->deleteResource( "/var/local/scf/" . $fname, 'file');
           $k->deleteResource( "/var/local/scf/" . $fname . ".tar", 'file' );
         }
      }
      case 'LOAD_RULES' {
         print $tee "+-- [step: $step] load iRules on a system\n";
         load_irules( $j );
      }
      case 'UNBIND_VS' {
         print $tee "+-- [step: $step] unbind iRules from vs on a system\n";
         my $z = {
           rules => []
         };
         foreach my $rs ( @{ $j->{'unbindvs'}} ) {
           my $js = JSON->new;
           $js->pretty();
           print $tee "  . updating virtual server: $rs\n";
           if (index($rs,"/") > -1){
             $rs =~ tr/\//~/;
           }
           #print Dumper( $z );
           putRequest( $URL . 'ltm/virtual/' . $rs, $js->encode( $z ) );
         }
      }
      case 'REBIND_VS' {
         print $tee "+-- [step: $step] rebind iRules on a virtual server\n";
         my $z = {
           rules => []
         };
         foreach my $rs (sort keys %{ $j->{'virtuals'}}) {
           my $js = JSON->new;
           $js->pretty();
           if (ref($j->{'virtuals'}{$rs}) eq "ARRAY") {
             $z->{'rules'} = $j->{'virtuals'}{$rs};
           } else {
             $z->{'rules'} = $j->{'virtuals'}{$rs}{'rules'};
             if (defined($j->{'virtuals'}{$rs}{'site'})){
               my $sk = $j->{'virtuals'}{$rs}{'site'};
               unless ($host_name =~ /^$sk/) {
                 next;
               }
             }
           }
           print $tee "  . updating virtual server: $rs\n";
           if (index($rs,"/") > -1){
             $rs =~ tr/\//~/;
           }
           #print Dumper( $z );
           if ($srun{'soft version'} =~ /^12/) {
             patchRequest( $URL . 'ltm/virtual/' . $rs, $js->encode( $z ) );
           } else {
             putRequest( $URL . 'ltm/virtual/' . $rs, $js->encode( $z ) );
           }
         }
      }
      case 'DELETIONS' {
         print $tee "+-- [step: $step] delete specified resources\n";
         # remove priorities first
         foreach my $r (sort keys %{ $j->{'delete'} }) {
           if ($j->{'delete'}{$r}[1] == 1) {
             my $prt = $j->{delete}{$r}[2] || "Common";
             printf $tee "  . removing priority object: %-52s  [", "/$prt/$r";
             if (deleteRequest( $URL . $j->{'delete'}{$r}[0] . "/~$prt~" . $r ) == 0) {
               print $tee "SUCCESS]\n";
             } else {
               print $tee "FAILED]\n";
             }
           }
         }
         # remove other items
         foreach my $r (sort keys %{ $j->{'delete'} }) {
           if ($j->{'delete'}{$r}[1] != 1) {
             my $prt = $j->{delete}{$r}[2] || "Common";
             printf $tee "  . removing normal object: %-52s  [", "/$prt/$r";
             if (deleteRequest( $URL . $j->{'delete'}{$r}[0] . "/~$prt~" . $r ) == 0) {
               print $tee "SUCCESS]\n";
             } else {
               print $tee "FAILED]\n";
             }
           }
         }
         # done
      }
      case 'RECERT' {
        print $tee "+-- [step: $step] recertify iRules\n";
        my $crt = $j->{'options'}{'signing_key'};
        print $tee "+-- using key: $crt\n";
        foreach my $r (sort keys %{ $j->{'rules'} }) {
          print $tee "  . processing iRule: $r\n";
          my $js = JSON->new;
          my $z = {
            command => 'generate',
            name    => $r,
            options => [
              {
                 signature => $r,
              }
            ],
            'signing-key' => $crt
          };
          $js->pretty();
          postRequest( $URL . "ltm/rule", $js->encode( $z ));
        }
      }
      case 'RENAME' {
        print $tee "+-- [step: $step] renaming objects\n";
        foreach my $rc (sort keys %{ $j->{'rename'} }) {
          print $tee "  . renaming $rc --> $j->{rename}{$rc}\n";
          my $js = JSON->new;
          my $z = {
            command => 'mv',
            name    => $rc,
            target  => $j->{'rename'}{$rc},
          };
          $js->pretty();
          postRequest( $URL . "ltm/virtual", $js->encode( $z ));
        }
      }
      case 'ABORT' {
        print $tee "+-- [step: $step] aborting batch\n";
        exit;
      }
      case 'VERIFY' {
        print $tee "+-- [step: $step] verifying batch feasibility\n";
        print $tee "  . veryfying existence of objects: vs\n";
        my %oDone = qw||;
        #
        # bind rules (only virtuals)
        foreach my $ob (sort keys %{ $j->{virtuals} }) {
          if (defined $j->{rename}) {
            foreach my $rn (sort keys %{ $j->{rename} }) {
              if ($j->{rename}{$rn} eq $ob){
                $ob = $rn;
                last;
              }
            }
          }
          print "   -> $ob    ";
          if (index($ob,"/") > -1){
            $ob =~ tr/\//~/;
          }
          if (query2object( $URL . "ltm/virtual/" . $ob) == 2){
             print $tee  "\[FAILED]\n -- ABORTED -- \n";
             exit;
           } else {
             print $tee "\[SUCESS]\n";
             $oDone{$ob} = 1;
           }
        }
        #
        # unbinding rules
        foreach my $ob (@{ $j->{unbindvs} }) {
          if (not defined $oDone{$ob}) {
            print $tee "   -> $ob    ";
            if (index($ob,"/") > -1){
              $ob =~ tr/\//~/;
            }
            if (query2object( $URL . "ltm/virtual/" . $ob) == 2){
               print $tee  "\[FAILED]\n -- ABORTED --\n";
               exit;
             } else {
               print $tee "\[SUCESS]\n";
             }
          }
        }
        #
        # deleted objects
        print $tee "  . looking for deleted objects \n";
        foreach my $ob (sort keys %{ $j->{delete} }) {
           print $tee "   -> $ob    ";
           my $prt = $j->{delete}{$ob}[2] || "Common";
           if (query2object( $URL . $j->{delete}{$ob}[0] . "/~$prt~" . $ob) == 2){
             print $tee "\[NOT FOUND]\n -- ABORTED -- \n";
             exit;
           } else {
             print $tee "\[SUCESS]\n";
           }
        }
      }
      case 'CONFIRM' {
         if (defined $j->{'confirm-msg'}) {
           if ($cindex) {
             print $tee ">>>>> $j->{'confirm-msg'}[$cindex - 1]";
           } else {
             print $tee ">>>>> $j->{'confirm-msg'}[$confNo]";
             $confNo++;
           }
         } else {
           print $tee ">>>>> Please confirm to proceed ....";
         }
         readline;
      }
      case 'SAVE' {
        print $tee "+-- [step: $step] saving running configuration\n";
        saveRunConfig;
      }
      case 'SYNC' {
        print $tee "+-- [step: $step] syncing cluster configuration\n";
        if (defined $props{'failover cluster'}) {
          print $tee "  . synchronizing configuration of the cluster: $props{'failover cluster'}...\n";
          syncCluster( $props{'failover cluster'} );
        }
      }
      case 'LOADTMSH' {
        if (defined $j->{'tmsh-merge'}) {
          print $tee "+-- [step: $step] merging tmsh config file: $j->{'tmsh-merge'}[$tmsh_mg]\n";
          if (defined $j->{'options'}{'base_location'}){
            my $k = new CAudit( $host, $usr, $pass, $cport );
            $k->uploadFile( $j->{'options'}, parseFileToken($j->{'tmsh-merge'}[$tmsh_mg]), $j->{'tmsh-merge'}[$tmsh_mg] );
          }
          my $r = loadMergeFile( $j->{'tmsh-merge'}[$tmsh_mg] );
          $tmsh_mg++;
        }
      }
      case 'UPLOAD' {
        if (defined $j->{'upload'}) {
          print $tee "+-- [step: $step] uploading object: $j->{'upload'}[$file_mg]\n";
          if (defined $j->{'options'}{'base_location'}){
            my $k = new CAudit( $host, $usr, $pass, $cport );
            $k->uploadFile( $j->{'options'}, parseFileToken($j->{'upload'}[$file_mg]), $j->{'upload'}[$file_mg] );
          }
          $file_mg++;
        }
      }
      case 'COMMAND' {
        if (defined $j->{'command'}) {
          print $tee "+-- [step: $step] execute command: $j->{'command'}[$cmd_mg]\n";
          my $r = runGenericCommand( $j->{'command'}[$cmd_mg] );
          if (defined $r->{'commandResult'}){
            printf $tee "  . (!!) unexpected command result: %s", $r->{'commandResult'};
          }
          $cmd_mg++;
        }
      }
      case 'LOAD_IFILES' {
        if ( (defined $j->{'ifile'}) && (defined $j->{'options'}{'base_location'}) ) {
          print $tee "+-- [step: $step] uploading ifiles\n";
          foreach my $fl (sort keys %{ $j->{'ifile'} }) {
            print $tee "  ifile: $fl\n";
            my $pa = 'Common';
            if (defined $j->{'ifile'}{$fl}{'partition'}) {
              $pa = $j->{'ifile'}{$fl}{'partition'};
            }
            if (existsResource( "sys/file/ifile/~$pa~$fl")) {
              updateResource('ifile', $fl, $pa, $j->{'options'}{'base_location'} . '/' . $j->{'ifile'}{$fl}{'source'});
            } else {
              createResource('ifile', $fl, $pa, $j->{'options'}{'base_location'} . '/' . $j->{'ifile'}{$fl}{'source'}, '');
            }
          }
        }
      }
      case 'LOAD_DG' {
        if ( (defined $j->{'datagroup'}) && (defined $j->{'options'}{'base_location'}) ) {
          print $tee "+-- [step: $step] uploading external data groups\n";
          foreach my $fl (sort keys %{ $j->{'datagroup'} }) {
            print $tee "  datagroup: $fl\n";
            my $pa = 'Common';
            my $tp = "string";
            if (defined $j->{'datagroup'}{$fl}{'partition'}) {
              $pa = $j->{'datagroup'}{$fl}{'partition'};
            }
            if (defined $j->{'datagroup'}{$fl}{'type'}) {
              $tp = $j->{'datagroup'}{$fl}{'type'};
            }
            if (existsResource( "sys/file/data-group/~$pa~$fl")) {
              updateResource('dgroup', $fl, $pa, $j->{'options'}{'base_location'} . '/' . $j->{'datagroup'}{$fl}{'source'});
            } else {
              createResource('dgroup', $fl, $pa, $j->{'options'}{'base_location'} . '/' . $j->{'datagroup'}{$fl}{'source'}, $tp);
            }
          }
        }
      }
      case 'LOAD_MONITORS' {
        if ( (defined $j->{'monitor'}) && (defined $j->{'options'}{'base_location'}) ) {
          print $tee "+-- [step: $step] uploading external monitors\n";
          foreach my $fl (sort keys %{ $j->{'monitor'} }) {
            print $tee "  external monitor: $fl\n";
            my $pa = 'Common';
            if (defined $j->{'monitor'}{$fl}{'partition'}) {
              $pa = $j->{'monitor'}{$fl}{'partition'};
            }
            if (existsResource( "sys/file/external-monitor/~$pa~$fl")) {
              updateResource('monitor', $fl, $pa, $j->{'options'}{'base_location'} . '/' . $j->{'monitor'}{$fl}{'source'});
            } else {
              createResource('monitor', $fl, $pa, $j->{'options'}{'base_location'} . '/' . $j->{'monitor'}{$fl}{'source'}, '');
            }
          }
        }
      }
      case 'DOWNLOAD' {
        if ( (defined $j->{'retrieve'}) && (defined $j->{'options'}{'store_location'}) ) {
          print $tee "+-- [step: $step] fetching files from remote system\n";
          foreach my $fl (sort keys %{ $j->{'retrieve'} }) {
            print $tee "  . resource from a location: $j->{'retrieve'}{$fl}\n";
            my $k = new CAudit( $host, $usr, $pass, $cport );
            $k->downloadResource( 'file', $j->{'retrieve'}{$fl}, $j->{'options'}{'store_location'} . '/' . $fl );
          }
        }
      }
    } # SWITCH
  }
}
sub parseFileToken
{
  my @fn = split( '/', shift );
  return $fn[$#fn];
}

#
# compute sha1 from a file contents
sub get_file_sha1
{
  my ($fn, $mode) = @_;
  open my $fh, "<", $fn or die "--- Error opening resource file $fn!\n";
  read $fh, my $buffer, -s $fh;
  if ($mode eq 'iRule') { chomp($buffer); }
  close $fh;

  return sha1_hex( $buffer );
}

#
# get contents of a file into a buffer
sub get_file_content
{
  my ($fname) = @_;
  open my $fh, "<", $fname or die "--- Error opening resource file $fname!\n";
  read $fh, my $buffer, -s $fh;
  close $fh;

  return $buffer;
}

#
# load irules onto F5 device
sub load_irules
{
  my $c = shift;
  my $f = shift;
  my %rls = checkRules();
  my @rs;

  # load file into buffer
  my %rules = ();

  if ($f and $f ne '') {
    print $tee "  . load_rules:: using ruleset definition: $f\n";
    %rules  = %{ $c->{'ruleset'}{$f} };
  } else {
    %rules = %{ $c->{'rules'} };
  }

  foreach my $rl (sort keys %rules) {
    if (defined $rules{$rl}{'priority'}) {
      push @rs, $rl;
    }
  }
  foreach my $rl (sort keys %rules) {
    if (not defined $rules{$rl}{'priority'}) {
      push @rs, $rl;
    }
  }

  foreach my $rl ( @rs ) {
    my $fhss = "$c->{'options'}{rules_location}/$rl.tcl";
    my $fhss_sha = get_file_sha1( $fhss, 'iRule' );
    if (defined $rls{$rl}) {
      if ($fhss_sha ne $rls{$rl}{'hash'}) {
        print $tee "  . \x1b[34mupdating rule: $rl\x1b[0m <local: $fhss_sha, remote: $rls{$rl}{'hash'}>\n";
        updateResource('rule', $rl, 'Common', $fhss);
      } else {
        print $tee "  . \x1b[32mrule: $rl is uptodate\x1b[0m <hash $fhss_sha>\n";
      }
    } else {
      print $tee "  . \x1b[33minstalling rule: $rl\x1b[0m <hash $fhss_sha>\n";
      createResource('rule', $rl, 'Common', $fhss, '');
    }
  }
}

# Reports

#
# ISTATS generic report
sub report_istats_generic
{
  my $r = runGenericCommand("istats dump");
  if (defined( $r->{'commandResult'})) {
    print $tee "+-- Report::Istats\n";
    print $tee '-'x 90 . "\n";
    printf $tee " %12s | %12s | %32s | %-20s\n",'Module','Range','Variable', 'Value';
    print $tee '-'x 90 . "\n";
    foreach my $ln ( split "\n", $r->{commandResult} ) {
      if ($ln =~ /^\s+\[\s*?(.+?)\s*?\]\[\s*?(.+?)\s*?\] = (.+?) .*/) {
        my ($code,$scope) = split('=', $1);
        my $var = $2;
        my $val = $3;
        printf $tee " %12s | %12s | %32s | %-20s\n",$code,$scope,$var,$val;
      }
    }
    print $tee '-'x 90 . "\n";
  } else {
    print $tee "-- report failed.\n"
  }
}
#
# string trimming
sub ctrim
{
  my $str = shift;
  chomp($str);
  $str =~ s/[,;]//g;
  $str =~ s/^\s+|\s+$//g;
  return $str;
}

#
# compare DB variables
sub report_dbvars {
  my ($defs) = @_;

  my $dbs = query2object($URL . 'sys/db');
  print $tee '-' x 120 . "\n";
  printf " %48s | %24s | %24s | %8s \n", 'Variable', 'Wanted', 'Check', 'Status';
  print $tee '-' x 120 . "\n";
  foreach my $r ( @{ $dbs->{'items'} } )
  {
    if (grep { /^$r->{'fullPath'}$/ } keys %{ $defs })
    {
      my $state = "[\033[32mPASS\033[0m]";
      my $sval = $r->{'value'};
      if ($r->{'value'} ne $defs->{$r->{'fullPath'}}) {
        $state = "[\033[31mFAIL\033[0m]";
      }
      printf $tee " %48s | %24s | %24s | %8s\n", $r->{'fullPath'}, $defs->{$r->{'fullPath'}}, $r->{'value'}, $state;
    }
  }
  print $tee '-' x 120 . "\n";
}

# compare iRules on the Box vs a baseline
# uses a baseline option
sub report_irules
{
   my ($base, $diff, $j) = @_;

   if ($base eq '') {
     print $tee "-- cannot compare iRule without a baseline directory <base>\n";
     return;
   }

   my $nset = 0;
   my $ndir = 0;
   my $ngod = 0;
   my $nmis = 0;
   my $ndif = 0;

   opendir my $dir, $base or die "Cannot open directory: $!";
   my @files = grep { /^.+?\.tcl$/ } readdir $dir;
   closedir $dir;

   my $rules = query2object( $URL . 'ltm/rule');
   my %failed = qw||;

   printf $tee " %50s\tStatus\n", "Rule name";
   print $tee '-' x 100 . "\n";

   $ndir = $#files;

   foreach my $f (sort @files) {

     if ($j->{'rules'}){
       $nset = scalar keys %{ $j->{'rules'} };
       my $la = $f;
       $la =~ s/.tcl//;
       if (! grep { /$la/ } keys %{$j->{'rules'}}) {
         printf $tee " %50s\t[\033[33mSKIP\033[0m]\n", $f;
         next;
       }
     }

     open my $fh, "<", $base . "/$f" or die "--- Error opening resource file $f!\n";
     read $fh, my $buffer, -s $fh;
     close $fh;
     # remove newline
     chomp($buffer);
     my $oh = sha1_hex( $buffer );

     $f =~ s/.tcl//;
     printf $tee " %50s", $f;

     my $found = 0;
     foreach my $r ( @{ $rules->{'items'} } )
     {
        if ($r->{'name'} eq $f) {
          $found = 1;
          my $ih = sha1_hex( $r->{'apiAnonymous'} );
          if ($oh ne $ih) {
            if ($^O eq "MSWin32") {
              printf $tee "\t[FAIL] %d %d\n", length($buffer) , length($r->{'apiAnonymous'});
            } else {
              printf $tee "\t[\033[31mFAIL\033[0m] %d %d\n", length($buffer) , length($r->{'apiAnonymous'});
            }
            # my $df = diff \$r->{'apiAnonymous'}, \$buffer, { STYLE => "Unified" };
            # compare changes over time over the base
            my $df = diff \$buffer, \$r->{'apiAnonymous'}, { STYLE => "Unified" };
            $failed{$f} = $df;
            $ndif++;
          } else {
            print $tee "\t[\033[32mOK\033[0m] \n";
            $ngod++;
          }
          last;
        }
     }
     if (! $found) {
       print $tee "\t[\033[34mMISS\033[0m] \n";
       $nmis++;
     }

   }
   print $tee '-' x 100 . "\n";
   printf $tee ". irules found in reference directory:    %d\n", $ndir;
   printf $tee ". irules declared in a batch and checked: %d\n", $nset if $nset > 0;
   printf $tee ". stats: OK: %d, DIFF: %d, MISS: %d \n", $ngod, $ndif, $nmis;
   print $tee '-' x 100 . "\n";

   if ($diff eq "true") {
     foreach my $d (sort keys %failed) {
       if ($^O eq "MSWin32") {
         printf $tee "--- [%s]:\n", $d;
       } else {
         printf $tee "\033[32m--- [%s]:\033[0m\n", $d;
       }
       my @lines = split /[\n]/, $failed{$d};
       foreach my $l (@lines) {
         if ($l =~ /^\-/) {
           print $tee $l . "\n";
         } elsif ($l =~ /^\@\@/) {
           if ($^O eq "MSWin32") {
             printf $tee "%s\n", $l;
           } else {
             printf $tee "\033[35m%s\033[0m\n", $l;
           }
         } else {
           if ($^O eq "MSWin32") {
             printf $tee "%s\n", $l;
           } else {
             printf $tee "\033[33m%s\033[0m\n", $l;
           }
         }
       }
     }
   }
}
#
# Custom reports
sub run_custom_report
{
  print ". not implemented\n";
}
# EOF
