#!/usr/bin/perl -w

#
# (C) Krystian Baniak 2020
#
# contact: krystian.baniak@exios.pl
# license: MIT
# program: f5-cfg
# description: tool for managing F5 LTM devices via iControl REST
#              allows for batch processing for complex transactions
#

use strict;
use warnings;

# remember from where we are called
my $rundir = $ENV{PWD};

BEGIN {
  use Cwd;
  use File::Basename;
  $rundir = qx{pwd};
  my $__base = dirname(__FILE__);
  if ( -l __FILE__) {
    $__base = dirname(readlink(__FILE__));
  }
  chdir($__base) || die ". cannot chdir into $__base";
  push (@INC, "./lib");
}

use Switch;
use JSON;
use Data::Dumper;
use HTTP::Request::Common;
use HTTP::Request;
use Getopt::Std;
use LWP::UserAgent;
use Digest::SHA qw(sha1 sha1_hex sha1_base64);
use File::Path qw(remove_tree);
use POSIX qw(strftime);
use Text::Diff;
use IO::Tee;
use URI::Escape;

use CAudit;
use CCache;
use COpts;

my $version = '1.4.7';
my $tee = \*STDOUT;

# --------- DEB -----------------
my $debug_vs = 0;
my $debug_prof = 0;
my $debug_rules = 0;
# --------- DEB -----------------

# -- hack needed to support F5 iCR API transactions
{
  no warnings;
  unless (defined &PATCH) {
    print "+: adding a PATCH subroutine for LWP agent\n";
    sub PATCH  { _simple_req('PATCH',  @_); }
  }
}
# --

our ( %opts );
getopts('u:p:O:t:q:fdhAikKTrQc:C:I:JsSx:R:w:l:b:B:Z:P:D:v:', \%opts);

unless ($opts{'Q'}) {
  printf ". runtime location: %s, rundir: %s\n", getcwd(), $rundir;
  print("\x1b[92m(C) 2020, Krystian Baniak <krystian.baniak\@exios.pl>,  F5 restful configuration tool, version: $version\x1b[0m\n");
}
#-------------------------------------------------
# advanced options parser
my $popts = COpts->new();
if ($opts{'O'}) {
  $popts->parse( $opts{'O'} );
  if ($popts->isFailed()){
    print "-- error in parsing options! Aborting ...\n";
    exit 3;
  }
}
#-------------------------------------------------
# help message
if ($opts{'h'}){
  my $__odefs = $popts->describe;
  my $__bdefs = $popts->batch_describe;
  print <<QQQ
--- [*] help section:

 invocation:
   $0 <options>

 options:
 --------------------------------------------------------------------------------------------

   -h           : this help message
   -d           : debug mode
   -q query     : single query mode, will not produce output file
   -u user      : user, default is admin
   -p password  : password, default is admin
   -f           : password will be read from the stdin after a prompt
   -t host      : f5 mgmt interface's IP address to query
   -A           : create archive containing iRules and iCall scripts
   -l name      : label used to create archive file name (affects -A option)
   -i           : identify f5 box
   -k           : verify iRule versions and allocation to virtual servers
   -K           : verify listeners and their allocation to virtual servers
   -c name      : create iRule or other resource from a file given in -I option
   -C name      : update iRule or other resource from a file given in -I option
   -D name      : dump given iRule to a working directory
   -I           : input resource
   -J           : modifies batch mode to return silently json response
   -P           : port to connect to
   -r           : retain temporal objects (used with -A option)
   -s           : save config
   -S           : sync cluster
   -w           : working directory
   -l name      : affect -a and -A by unifying the name of the resource
   -b name      : batch mode that uses json file as input
   -B steps     : semicolon delimited list of steps, mutually exclusive with -b option
   -Z step      : select step set from a step set list, used only with a -b option
   -x cmd       : execute advanced script action
   -R name      : run special report name [ availability depends on version ]
   -T           : use token based authentication
   -Q           : quiet mode - supress logs to a file
   -O opts      : list of options param=value,param=value, use %20 to escape a white space
                  example:  base=gen8.2/test,label=ala%20ma%20kota
   -v string    : batch mode variables (see opts for syntax)

 --------------------------------------------------------------------------------------------

 list of known options:
$__odefs

 list of known batch commands
$__bdefs

--- *
QQQ
  ;
  exit;
}

STDOUT->autoflush(1);

# -- Orange F5 nodes
my %nodes = %{ load_dataset_from_file('./cfg/nodes.json', 'nodes') };
my %props = ();
my %srun = ();
# ----------------- SETTINGS --------------------
my $usr   = $opts{'u'} || 'admin';
my $pass  = $opts{'p'} || 'admin';
my $host  = $opts{'t'} || '192.168.1.254';
my $ifns  = $opts{'I'} || 'input.txt';
my $wDir  = $opts{'w'} || '';
my $Label = $opts{'l'} || '';
my $bstep = $opts{'Z'} || '';
my $cport = $opts{'P'} || 443;
my $URL_BARE = "https://$host/";
my $URL   = "https://$host/mgmt/tm/";
my $URLB  = "https://$host/mgmt/shared/authn/login";
my $host_name = $host;
my $tmp_stmp = &gen_tmstmp;
my %ems;
my $tks = '';
if ($opts{'P'}) {
  $URL_BARE = "https://$host:$opts{'P'}/";
  $URL   = "https://$host:$opts{'P'}/mgmt/tm/";
  $URLB  = "https://$host:$opts{'P'}/mgmt/shared/authn/login";
}
# global operation flags
my %rflags = (
  'req_not_fatal'    => 0,
  'req_error_silent' => 0
);
#-------------------------------------------------
# Authentication Cache
my $cache = CCache->new("./cfg/.ccache.json");
unless (-e "./cfg/.ccache.json") {
  print "-- creating new empty cache file.\n";
  $cache->setup_authcache( \%nodes );
  $cache->save;
}
$cache->open;
# interactive password retrieval
if ($opts{'f'}) {
  $pass = $cache->getUserCredentials;
}
#-------------------------------------------------
# Log file settings
# by default we make a transation log fom every script invocation
# the results are kept in the logfiles directory
unless (-e "logfiles" && -d "logfiles") {
  mkdir "logfiles";
}
my $log_fname = "logfiles/config-audit-log-${tmp_stmp}.log";
if ($popts->get('onelog') eq "yes") {
  $log_fname = "logfiles/config-audit-log.log";
}
if ($opts{'Q'} or ($popts->get('supress_log') eq "yes")) {
  #print "+ supressing transactional logging...\n";
} else {
  $tee = new IO::Tee(\*STDOUT, new IO::File(">$log_fname"));
}
#-------------------------------------------------
# determine host and authentication details
update_host( $host );
#-------------------------------------------------
# working directory settings
my $remove_temp = 1;
if ($opts{'r'}) { $remove_temp = 0; }
if ($wDir ne '') {
  if (! -e $wDir) {
    printf $tee "!-- working directory not found: $wDir\n";
    exit;
  }
} else {
  $wDir = $rundir;
}
# -----------------------------------------------
# Debug settings
my $db_cr = 0;
if ($opts{'d'}) {
  # enable all kinds of debug
  $debug_vs = $debug_prof = 1;
  $db_cr = 1;
}
#------------------------------------------------
# LWP settings
my $ua   = new LWP::UserAgent;
$ua->timeout(600);
$ua->ssl_opts( verify_hostname => 0, SSL_verify_mode => 0x00 );
#------------------------------------------------
# F5 token based authentication
if ($opts{'T'}) {
  $tks = &tokenRequest;
  #print Dumper($tks);
  if ($tks->{token}) {
    $tks = $tks->{token}{token};
    print "++ token: $tks\n";
  }
}
#-----------------------------------------------
# Properties are needed for Batch mode
if ($popts->get('bigiq') ne '') {

} else {
  # get big-ip properties
  &update_platform_properties;
  if ($opts{'i'}){
    &print_platform_properties;
  }
}
#-----------------------------------------------
# batch mode
if ($opts{'b'}) {
  if (!$opts{Q}) {
    print $tee "+-- running in a batch mode\n";
    print $tee "+-- processing input file: \x1b[33m$opts{'b'}\x1b[0m\n";
  }
  if ($opts{'B'}) { print $tee "!-- you cannot use -b and -B simultaneously\n"; exit 4; }
  batch_mode( $opts{'b'}, 'file' );
  exit;
}
if ($opts{'B'}) {
  if ($opts{'b'}) { print $tee "!-- you cannot use -b and -B simultaneously\n"; exit 4; }
  batch_mode( $opts{'B'}, 'inline' );
  exit;
}
# -- iRule dump mode
if ($opts{'D'} && $opts{'D'} ne "") {
  my $_f = 0;
  my $rules = query2object( $URL . 'ltm/rule');
  foreach my $r ( @{ $rules->{'items'} }) {
    next if ($r->{'name'} =~ /^_sys_/);
    if ($r->{'name'} eq $opts{'D'}) {
      print $tee ". dumping iRule: $r->{'name'}, partition: $r->{'partition'}\n";
      if (-e "$wDir/$opts{'D'}.tcl") {
        printf $tee "\x1b[33m** Warning:\x1b[0m the iRule with that name already found in your current directory!, old: %s, dumped: %s\n", sha1_hex(get_file_content("$wDir/$opts{'D'}.tcl")), sha1_hex( $r->{'apiAnonymous'} );
      }
      open my $fh, ">", "$wDir/$r->{'name'}.tcl.$tmp_stmp" or terminate_with_error($tee, 'file create', "Error creating iRule file");
      print $fh $r->{'apiAnonymous'};
      close($fh);
      $_f = 1;
      last;
    }
  }
  unless ($_f) {
    print $tee "! iRule not found: $opts{'D'}\n";
  }
  exit;
}
# single query mode
if ($opts{'q'}) {
 print $tee "received query: $opts{'q'}\n";
 my $p = $opts{'q'};
 if ($p and $p ne '-') {
   my $curl = $URL;
   if ($popts->get('bigiq') ne '') {
     $curl = $URL_BARE;
   }
   if ($popts->get('format') eq 'json') {
     print $tee query2json( $curl . $p );
   } else {
     print $tee Dumper( query2object( $curl . $p ));
   }
 }
 exit;
}
#------------------------------------------------
# cmd mode
if ($opts{'x'}) {
  my $data = runGenericCommand($opts{'x'});
  if ($popts->get("respOnly") ne "") {
    if (defined $data->{'commandResult'}) {
      print $tee $data->{'commandResult'};
    } else {
      print $tee "-- command failed. \n";
    }
  } else {
    print Dumper( $data );
  }
  exit;
}
#-----------------------------------------------
# Report mode
if ($opts{'R'}) {
  if ($opts{'i'}){
    &update_platform_properties;
    &print_platform_properties;
  }
  print $tee "+ running report: $opts{'R'} \n";
  my $tms = strftime("%a %d %b %H:%M:%S %Y", localtime);
  printf $tee "+ timestamp: %s\n", $tms;
  switch ($opts{'R'}) {
    case 'RULE' {
      &report_irules($popts->get('base'), $popts->get('diff'));
    }
    case 'ISTATS' {
      &report_istats_generic;
    }
    default {
      &run_custom_report($opts{'R'});
    }
  }
  exit;
}
#-----------------------------------------------
# create commands
if ($opts{'c'} or $opts{'C'}) {
  my $_t = 'rule';
  my $floc = $ifns;

  if (substr($ifns,0,2) eq './') {
    substr($floc,0,1) = $rundir;
  }

  if (scalar( grep {! /\//} $ifns)) {
    $floc = $rundir . '/' . $ifns;
  }

  if ($popts->get('ctype') ne "") {
    $_t = $popts->get('ctype');
  }

  if ($opts{'c'}) {
    print $tee "+ creating resource of type: $_t: $opts{'c'} from: $floc\n";
    createResource($_t, $opts{'c'}, 'Common', $floc, '', undef);
  } else {
    print $tee "+ updating resource of type: $_t: $opts{'C'} from: $floc\n";
    updateResource($_t, $opts{'C'}, 'Common', $floc, undef);
  }
  exit;
}
#-----------------------------------------------
if ($opts{'k'}) {
  print $tee "+ analysing iRules and their alloactions ...\n";
  checkRules( 1 );
  exit;
}
#-----------------------------------------------
if ($opts{'K'}) {
  print $tee "+ analysing Listeners and their alloactions ...\n";
  &checkVirtuals;
  exit;
}
#-----------------------------------------------
if ($opts{'s'}) {
  print $tee "+ saving configuration ...\n";
  &saveRunConfig;
  exit;
}
#-----------------------------------------------
if ($opts{'S'}) {
  if (defined $props{'failover cluster'}) {
    print $tee "+ synchronizing configuration in the cluster: $props{'failover cluster'}...\n";
    syncCluster( $props{'failover cluster'} );
  }
  exit;
}
#-----------------------------------------------
# save iRules and iCall scripts into an archive
#
if ( $opts{'A'} ) {
  if ($wDir ne '') { printf $tee "++ using workdir: $wDir\n"; }
  my $d = "${host_name}_archive";
  if ($Label ne '') {
    $d = "${Label}_archive_${host_name}_${tmp_stmp}";
  }
  print "++ creating databook archive: $d\n";
  mkdir $d;
  mkdir "$d/iRules";
  my $rules = query2object( $URL . 'ltm/rule');
  if ($debug_rules) { print Dumper($rules); }
  foreach my $r ( @{ $rules->{'items'} }) {
    next if ($r->{'name'} =~ /^_sys_/);
    print $tee "dumping iRule: $r->{'name'}, partition: $r->{'partition'}\n";
    unless (-e "$d/iRules/$r->{'partition'}"){
      mkdir "$d/iRules/$r->{'partition'}";
    }
    open my $fh, ">", "$d/iRules/$r->{'partition'}/$r->{'name'}.tcl" or terminate_with_error($tee, 'irule create', "cannot save iRule file on local disk");
    print $fh $r->{'apiAnonymous'};
    close($fh);
  }

  mkdir "$d/Scripts";
  my $scr = query2object( $URL . 'cli/script' );
  foreach my $r ( @{ $scr->{'items'} } ) {
    print $tee "dumping cli script: $r->{'name'}, partition: $r->{'partition'}\n";
    unless (-e "$d/Scripts/$r->{'partition'}"){
      mkdir "$d/Scripts/$r->{'partition'}";
    }
    open my $fh, ">", "$d/Scripts/$r->{'partition'}/$r->{'name'}.tcl" or terminate_with_error($tee, 'irule create', "cannot save iRule file on local disk");
    print $fh $r->{'apiAnonymous'};
    close($fh);
  }

  my $dg = query2object( $URL . 'ltm/data-group/internal');
  my $js = JSON->new;
  $js->pretty();
  open my $fh, ">", "$d/data-groups-internal.json" or terminate_with_error($tee, 'data-group create', "cannot save data-group on a local disk");
  foreach my $r ( @{ $dg->{'items'} }) {
    print $fh $js->encode($r);
  }
  close($fh);

  if ($^O eq "MSWin32") {
    `tar -cf $wDir/$d.tar $d/`;
  } else {
    `tar -cf $wDir/$d.tar $d/`;
  }
  if ($remove_temp) {
    print $tee "... trying to remove directory";
    remove_tree("$d");
  }
}
print $tee "+++ job's done.";
exit;

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# Routines

sub generate_JSON_response
{
  my ($def) = @_;
  my $k = {
    appName => '(C) 2021 f5-cfg-tool by Krystian Baniak',
    version => $version,
  };
  foreach my $pr (sort keys %{ $def }) {
    $k->{$pr} = $def->{$pr};
  }
  return $k
}
#
# rflags
sub set_rflag
{
  my ($p, $v) = @_;
  $rflags{$p} = $v;
}
# finds all static variable declarations from a stream and stores in hash reference
# params: ref to hash and buffer with iRule contents
sub find_static_vars
{
  my ($ref, $data, $rname) = @_;
  my $reg=0;

  if (! defined($ref->{'errors'})) {
    $ref->{'errors'} = qw();
  }
  foreach my $k ( split(/[\r\n]/, $data)) {
    if ($reg) {
      if ($k =~ /^when/) {
        last;
      }
      chomp($k);
      if ($k !~ /array set static/) {
        if ($k =~ /set static::(.+?)\s+(.+?)$/) {
          #print ". found a static variable: $1 $2\n";
          if (defined $ref->{$1}) {
            # this static var is redefined
            #print "ERROR\n";
            push @{ $ref->{'errors'} }, "collision in: $rname, var: $1 = $2, previosly found in: $ref->{$1}{'rule_name'} = $ref->{$1}{'value'}";
          } else {
            $ref->{$1} = { value => $2, rule_name => $rname };
          }
        }
      }
    }
    $reg=1 if $k =~ /^when RULE_INIT/;
  }
  return $ref;
}

sub terminate_with_error {
  my ($hf, $heading, $msg) = @_;

  printf $hf "[\x1b[31m fatal \x1b[0m]: %s: \x1b[31m%s\x1b[0m\n", $heading, $msg;
  exit 1;
}

#
# load config from a file with json encoding
sub load_dataset_from_file
{
  my ($fname, $type) = @_;
  open my $fh, "<", "$fname" or terminate_with_error($tee, 'file open', "Error opening resource file: $fname");
  read $fh, my $buffer, -s $fh;
  close $fh;
  my $k = decode_json( $buffer );
  if (defined($k->{$type})) {
    return $k->{$type};
  } else {
    return undef;
  }
}

# update platform structures
sub update_platform_properties {
  %props = &get_propsy;
  %srun  = &get_running_software;
}
# print information about F5 device (or a cluster node)
sub print_platform_properties {
  print $tee "system properties: \n";
  foreach my $k (sort keys %props){
    printf $tee "  %40s: %s\n", $k, $props{$k};
  }
  foreach my $k (sort keys %srun){
    printf $tee "  %40s: %s\n", $k, $srun{$k};
  }
}
#
# update host structures
sub update_host {
  my $_h = shift;
  my $md = shift || 'full';

  if ($_h =~ /^[a-zA-Z]/) {
    $host_name = $_h;
    if (defined( $nodes{ $_h } )){
      $host = $nodes{ $_h };
    } else {
      print $tee "--- unknown host given!\n";
      exit 100;
    }
  } elsif ($_h =~ /^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$/) {
    $host_name = $host = $_h;
  } else {
    print $tee "fatal: cannot switch host\n";
    exit 101
  }

  # update all globals
  if ($cport != 443) {
    $URL_BARE = "https://$host:$cport/";
    $URL   = "https://$host:$cport/mgmt/tm/";
    $URLB  = "https://$host:$cport/mgmt/shared/authn/login";
  } else {
    $URL_BARE = "https://$host/";
    $URL = "https://$host/mgmt/tm/";
    $URLB = "https://$host/mgmt/shared/authn/login";
  }
  unless ($opts{'Q'}) { print $tee "+ host $host_name mapped to: [ $host ]\n"; }

  # perform auth cache scan if needed
  if ($md eq 'full') {
    my ($_u, $_p) = $cache->check_auth( $_h );
    if (($_u ne 'x') and ($_u ne $usr)) { $usr = $_u; }
    if (($_p ne 'x') and ($_p ne $pass)) { $pass = $_p; }
  }
}
#
# generate timestamp
sub gen_tmstmp {
  my $ss = strftime "%d%m%y-%H%M%S", localtime;
  return $ss;
}

#
# get system properties
sub get_propsy {
  my %p;
  my $r = query2object( $URL . 'sys/hardware');
  $p{'marketingName'} = $r->{'entries'}{'https://localhost/mgmt/tm/sys/hardware/platform'}{'nestedStats'}{'entries'}{'https://localhost/mgmt/tm/sys/hardware/platform/0'}{'nestedStats'}{'entries'}{'marketingName'}{'description'};
  $p{'baseMac'} = $r->{'entries'}{'https://localhost/mgmt/tm/sys/hardware/platform'}{'nestedStats'}{'entries'}{'https://localhost/mgmt/tm/sys/hardware/platform/0'}{'nestedStats'}{'entries'}{'baseMac'}{'description'};
  $p{'bigipChassisSerialNum'} = $r->{'entries'}{'https://localhost/mgmt/tm/sys/hardware/system-info'}{'nestedStats'}{'entries'}{'https://localhost/mgmt/tm/sys/hardware/system-info/0'}{'nestedStats'}{'entries'}{'bigipChassisSerialNum'}{'description'};
  $p{'platform'} = $r->{'entries'}{'https://localhost/mgmt/tm/sys/hardware/system-info'}{'nestedStats'}{'entries'}{'https://localhost/mgmt/tm/sys/hardware/system-info/0'}{'nestedStats'}{'entries'}{'platform'}{'description'};
  $r = query2object( $URL . 'cm/device-group');
  foreach my $e ( @{ $r->{'items'} }) {
    if ($e->{'type'} eq 'sync-failover') {
      $p{'failover cluster'} = $e->{'name'};
    }
  }
  $r = query2object( $URL . 'cm/device' );
  $p{'fovState'} = 'passive';
  foreach my $e ( @{ $r->{'items'}} ) {
    if ($e->{'managementIp'} eq $host) {
      if ($e->{'failoverState'} eq 'active'){
        $p{'fovState'} = 'active';
      }
    }
  }
  return %p;
}

#
# query 2 JSON
sub query2json
{
  my $uri = shift;
  my $mode = shift || 'no';

  if ($mode eq 'yes') {
    $uri =~ s/localhost/$host/;
  }
  if ($opts{'P'}){
    if ($uri =~ /^https:\/\/([^\/:]+)\/(.+)$/) {
      $uri = "https://$1:$opts{'P'}/$2";
      print ". modif --> $uri\n";
    }
  }
  my $r = GET $uri;
  if ($opts{'T'}){
    $r = GET $uri, 'X-F5-Auth-Token' => $tks;
  } else {
    $r->authorization_basic($usr, $pass);
  }
  my $res = $ua->request( $r );
  my $cd = $res->code;
  my $resp = $res->content;

  my $js = JSON->new;
  $js->pretty;

  if (not $cd =~ /(200|202)/) {
    if (($cd eq 404) && ($resp =~ /was not found/ || $resp =~ /Public URI path not registered/)){
      return $js->encode( { error => 'not found' } );
    } else {
      if ($mode eq 'do_not_fail') {
        return $js->encode( { error => '404' } );
      } else {
        print $tee "--- http get req error, code: $cd\n";
        print $tee "--- response: $resp\n";
        exit;
      }
    }
  }

  # we get final response
  if ($popts->get('save_query_result') eq 'yes') {
    if (! -e "$wDir/.creq-cache") {
      print $tee "- creating json cache dir: $wDir/.creq-cache\n";
      mkdir "$wDir/.creq-cache";
    }
    my $curi;
    if ($uri =~ /^https:\/\/.+\/mgmt\/tm\/(.+)$/) {
      $curi = $1;
      $curi =~ s/\?.*//;
      $curi = join('-', split('/', $curi));
      my $lcfile = "$wDir/.creq-cache/$host-$curi-$tmp_stmp.json";

      open my $fh, ">", $lcfile or terminate_with_error($tee, 'file create', "Error creating json file: $lcfile");
      print $fh $res->content;
      close $fh;
    }
  }

  # return results
  return $js->encode( $js->decode($res->content) );
}
#
# query 2 perl object
sub query2object
{
  my $uri = shift;
  my $mode = shift || 'no';

  return decode_json( query2json( $uri, $mode ) );
}

sub tokenRequest
{
  my $js = JSON->new;
  my $z = {
    username           => $usr,
    password           => $pass,
    loginProviderName  => 'tmos',
  };
  $js->pretty();

  my $r = POST $URLB, 'Content-Type' => 'application/json', 'Content' => $js->encode( $z );
  $r->authorization_basic($usr, $pass);
  my $res = $ua->request( $r );
  my $cd = $res->code;
  my $resp = $res->content;

  if (not $cd =~ /(200|202)/) {
    print $tee "--- http post req error, code: $cd\n";
    print $tee "--- response: $resp\n";
    exit;
  }

  return decode_json($res->content);
}

sub rawRequest
{
  my ($method, $uri, $js) = @_;
  my $r;
  switch ($method) {
    case 'POST' {
      $r = POST $uri, 'Content-Type' => 'application/json', 'Content' => $js;
    }
  };
  $r->authorization_basic($usr, $pass);
  return $ua->request( $r );
}

sub postRequest
{
  my $u = shift;
  my $js = shift;
  my $deb = shift || 'no';
  my $r = POST $u, 'Content-Type' => 'application/json', 'Content' => $js;
  $r->authorization_basic($usr, $pass);
  my $res = $ua->request( $r );
  my $cd = $res->code;
  my $resp = $res->content;

  if ($deb eq 'yes') {
    print $tee "--- response: $resp\n";
  }

  if ($cd !~ /(200|202)/) {
    unless ($rflags{'req_error_silent'}) {
      print $tee "--- http post req error, code: $cd\n";
      print $tee "--- response: $resp\n";
    }
    unless ($rflags{'req_not_fatal'}) { exit } else { return 'failed' }
  }

  return decode_json($res->content);
}

sub putRequest
{
  my $u = shift;
  my $js = shift;
  my $r = PUT $u, 'Content-Type' => 'application/json', 'Content' => $js;
  $r->authorization_basic($usr, $pass);
  my $res = $ua->request( $r );
  my $cd = $res->code;
  my $resp = $res->content;

  if ($cd !~ /(200|202)/) {
    unless ($rflags{'req_error_silent'}) {
      print $tee "--- http put req error, code: $cd\n";
      print $tee "--- response: $resp\n";
    }
    unless ($rflags{'req_not_fatal'}) { exit } else { return 'failed' }
  }

  return decode_json($res->content);
}

sub patchRequest
{
  my $u = shift;
  my $js = shift;
  my $r = HTTP::Request->new(PATCH => $u);
  $r->header( 'Content-Type' => 'application/json' );
  $r->content( $js );
  $r->authorization_basic($usr, $pass);
  my $res = $ua->request( $r );
  my $cd = $res->code;
  my $resp = $res->content;

  if ($cd !~ /(200|202)/) {
    unless ($rflags{'req_error_silent'}) {
      print $tee "--- http patch req error, code: $cd\n";
      print $tee "--- response: $resp\n";
    }
    unless ($rflags{'req_not_fatal'}) { exit } else { return 'failed' }
  }
  return decode_json($res->content);
}

sub deleteRequest
{
  my $u = shift;
  my $r = HTTP::Request->new(DELETE => $u);
  $r->authorization_basic($usr, $pass);
  my $res = $ua->request( $r );
  my $cd = $res->code;
  my $resp = $res->content;

  if ($cd !~ /(200|202)/) {
    if (($cd eq 404) && ($resp =~ /was not found/)){
      return 2;
    } else {
      unless ($rflags{'req_error_silent'}) {
        print $tee "--- http delete req error, code: $cd\n";
        print $tee "--- response: $resp\n";
      }
      unless ($rflags{'req_not_fatal'}) { exit } else { return 'failed' }
    }
  }
  return 0
}
#
# Converts Object to string
#
sub obj2str
{
  my $obj = shift;
  my $ret = "-";

  if (not defined($obj) or $obj eq '') {
    return $ret;
  }

  if (ref $obj eq 'ARRAY'){
    $ret = join("\n", map { &obj2str($_) } @{ $obj });
  } elsif (ref $obj eq 'HASH'){
    my @a = qw( { );
    foreach my $i (sort keys %{ $obj }){
      # filter common not displayable properties
      unless ($i =~ /^(selfLink|kind|fullPath|generation)$/) {
        push @a, $i . ": " . &obj2str( $obj->{$i} );
      }
    }
    push @a, '}';
    $ret = join("\n", @a);
  } else {
    $ret = $obj;
    $ret =~ tr/[\n\r]//;
  }

  return $ret;
}
#
# Convert array of Objects to a string
#
sub objectarray2string
{
  my $a = shift;
  my @ret;
  foreach my $it ( @{ $a } ){
    my @hh = qw( { );
    foreach my $_t (sort keys %{ $it }) {
      unless ($_t =~ /^(selfLink|kind|fullPath|generation)$/) {
          push @hh, $_t . ': ' . $it->{ $_t };
      }
    }
    push @hh, '}';
    push @ret, join( "\n", @hh);
  }
  return join( "\n", @ret );
}

#
# follow references and expand them by converting into objects
#
sub checkReference
{
  my $r  = shift;
  my $ar = [];

  if ($db_cr) { print " debug: checkReference\n"; }
  foreach my $e ( @{ $$r->{'items'} }){
    my $z = {};
    foreach my $p (keys %{ $e } ) {
      if ($p =~ /^(.+)Reference$/){
        my $ct = ref $e->{$p};
        # print "checkReference:  $ct: $p\n";
        #
        # since version 12.0 additional references are included in ARRAY for given property such as iRule, vlan, profile
        #
        if ($ct eq 'HASH') {
          my $qe = query2object( $e->{$p}{'link'}, 'yes');
          #$z->{$p} = objectarray2string( $qe->{'items'} );
          $z->{$p} = $qe->{'items'};
        }
      } else {
        $z->{$p} = $e->{$p};
      }
    }
    push @{ $ar }, $z;
  }
  $$r->{'items'} = $ar;
}

#
# same as above but for flat type of collections
#
sub checkReferenceFlat
{
  my $r  = shift;
  my $z = {};

  if ($db_cr) { print " debug: checkReferenceFlat\n"; }
  foreach my $p (keys %{ $$r } ){
    if ($p =~ /^(.+)Reference$/){
      my $ct = ref $$r->{$p};
      #print " cRF: $p : $ct";
      if ($ct eq 'HASH') {
        my $qe = query2object( $$r->{$p}{'link'}, 'yes');
        $z->{$p} = objectarray2string( $qe->{'items'} );
      }
    } else {
      $z->{$p} = $$r->{$p};
    }
  }
  $$r = $z;
}

sub dumpObject2Array {
  my $obj = shift;
  my $hea = shift || 0;
  my @a = qw( name );

  if ( ref $obj eq 'HASH' ){
    foreach my $e (sort keys %{ $obj }) {
      unless ($e =~ /^(selfLink|kind|name|fullPath|generation)$/) {
        push @a, $e;
      }
    }
    if ($hea) {
      return @a;
    } else {
      return map { if ($_ eq 'name'){ $obj->{'name'} } else { obj2str( $obj->{$_} ) } } @a;
    }
  }
  return @a;
}

#
# analyze virtual servers
#
sub checkVirtuals {
  my $vs = query2object( $URL . 'ltm/virtual' );
  printf $tee "\n %40s | %9s | %14s | %9s | %-40s\n",'name','partition','folder','type','vlan';
  printf $tee "%s\n", '-' x 110;
  foreach my $r ( @{ $vs->{'items'} } ) {
    my $v = $r->{'vlans'};
    if ( ref $v eq 'ARRAY' ){
      $v = join ', ', @{ $v };
    } else {
      $v = "-empty-";
    }
    my $subp = '';
    if (defined($r->{'subPath'})) {
      $subp = $r->{'subPath'};
    }
    printf $tee " %40s | %9s | %14s | %9s | %-40s\n", $r->{'name'}, $r->{'partition'}, $subp, $r->{'ipProtocol'}, $v;
  }
  printf $tee "%s\n", '-' x 110;
}

#
# analyze iRules
# returns a hash with irule_name as a key and props:
# - used      : 1|0
# - modified  : 1|0
# - hash      : sha1 of iRule code
# - partition
sub checkRules {
  my $rules = query2object( $URL . 'ltm/rule');
  if ($debug_rules) { print Dumper($rules); }
  my %RR = qw();
  my $verb = shift || 0;
  my %irules = qw();

  if ($verb) {
    printf $tee "\n %42s | %20s | %-40s\n",'name','partition','hash';
    printf $tee "%s\n", '-' x 160;
  }
  foreach my $r ( @{ $rules->{'items'} }) {
    next if ($r->{'name'} =~ /^_sys_/);
    my $dg = sha1_hex( $r->{'apiAnonymous'} || '' );
    my $key = "/" . $r->{'partition'} . "/" . $r->{'name'};
    if ($verb) { printf $tee " %42s | %20s | %40s\n", $r->{'name'}, $r->{'partition'}, $dg; }
    $RR{ $key } = 0;
    $irules{ $key } = {
       hash      => $dg,
       used      => 0,
       partition => $r->{'partition'},
    };
  }

  my $vss = query2object( $URL . 'ltm/virtual');
  if ($verb) {
    printf $tee "%s\n", '-' x 160;
    printf $tee "\n %42s | %12s | %32s | %-40s\n",'name','partition','application service','list of numbered iRules';
    printf $tee "%s\n", '-' x 160;
  }
  foreach my $r ( @{ $vss->{'items'}}) {
    my $rl = '';
    my $aps = $r->{'appService'} || '-';
    $aps =~ s/\/Common\///;
    if (defined $r->{'rules'}) {
      my $fo = 0;
      foreach my $k ( @{ $r->{'rules'}} ) {
        if (defined $RR{$k} ) {
          $RR{$k} = 1;
          $irules{$k}{used} = 1;
        }
        if ($fo == 0){
          $fo++;
          if ($verb) { printf $tee " %42s | %12s | %32s | [%2d]  %-40s\n", $r->{'name'}, $r->{'partition'}, $aps, $fo, $k; }
        } else {
          $fo++;
          if ($verb) { printf $tee " %42s | %12s | %32s | [%2d]  %-40s\n", ' ', ' ', ' ', $fo, $k; }
        }
      }
    } else {
      if ($verb) { printf $tee " %42s | %12s | %32s | %40s\n", $r->{'name'}, $r->{'partition'}, $aps, $rl; }
    }
  }
  if ($verb) {
    printf $tee "%s\n", '-' x 160;
    print $tee "\n+ unused iRules:\n";
    printf $tee "%s\n", '-' x 160;
    foreach my $k ( sort keys %RR ) {
      if ($RR{ $k } == 0) { print $tee "$k\n"; }
    }
    printf $tee "%s\n", '-' x 160;
  }
  return %irules;
}

sub saveRunConfig
{
  my $js = JSON->new;
  my $z = {
    command => "save",
  };
  $js->pretty();
  return postRequest( $URL . 'sys/config', $js->encode( $z ), 'no' );
}

sub syncCluster
{
  my $grp = shift;
  my $js = JSON->new;
  my $z = {
    command     => "run",
    utilCmdArgs => "config-sync to-group $grp",
  };
  # force-full-load-push
  $js->pretty();
  return postRequest( $URL . 'cm', $js->encode( $z ), 'yes' );
}

sub runGenericCommand
{
  my $cmd = shift;
  my $js = JSON->new;
  my $z = {
    command     => "run",
    utilCmdArgs => " -c '$cmd'",
  };
  $js->pretty();
  return postRequest( $URL . 'util/bash', $js->encode( $z ) );
}

sub loadMergeFile
{
  my $fle = shift;
  my $js = JSON->new;
  my $z = {
    command     => "load",
    utilCmdArgs => "merge file $fle",
  };
  $js->pretty();
  return postRequest( $URL . 'sys/config', $js->encode( $z ) );
}

sub verifyMergeFile
{
  my $fle = shift;
  my $js = JSON->new;
  my $z = {
    command     => "load",
    utilCmdArgs => "merge file $fle verify",
  };
  $js->pretty();
  my $r = rawRequest( 'POST', $URL . 'sys/config', $js->encode( $z ) );
  if ($r->code eq 200) {
    return 'OK';
  } else {
    my $m = decode_json( $r->content );
    return $m->{'message'};
  }
}

sub createResource
{
  my ($t, $n, $part, $r, $mds, $ops) = @_;
  my $js = JSON->new;
  $js->pretty();

  if ($t eq 'rule') {
    open my $fh, "<", "$r" or terminate_with_error($tee, 'file open', "Error opening resource file: $r");
    read $fh, my $buffer, -s $fh;
    close $fh;
    my $z = {
      name => $n,
      kind => 'tm:ltm:rule:rulestate',
      partition => $part,
      apiAnonymous => $buffer,
      fullPath => "/" . $part . "/" . $n,
    };
    return postRequest( $URL . 'ltm/rule/', $js->encode( $z ) );
  }

  if ($t eq 'ifile') {
    my $transname = "/shared/tmp/tmp-auto-$n-" . $tmp_stmp;
    my $k = new CAudit( $host, $usr, $pass, $cport );
    $k->uploadFile( $ops, $r, $transname );

    my $r = runGenericCommand( "tmsh create sys file ifile /$part/$n source-path file://$transname" );
    if (defined( $r->{'commandResult'})) {
      print $tee "error while creating resource: " . $r->{'commandResult'};
      runGenericCommand( "rm $transname" );
      exit 1;
    }
    runGenericCommand( "rm $transname" );

    # create ltm link for an ifile
    my $z = {
      name      => $n,
      kind      => 'tm:ltm:ifile:ifilestate',
      partition => $part,
      fullPath  => "/$part/$n",
      fileName  => "/$part/$n"
    };
    my $ck = existsResource( "ltm/ifile/~$part~$n" );
    if ($ck) {
      return $ck;
    } else {
      return postRequest( $URL . 'ltm/ifile/', $js->encode( $z ) );
    }
  }

  if ($t eq 'dgroup') {
    my $transname = "/shared/tmp/tmp-auto-$n-" . $tmp_stmp;
    my $k = new CAudit( $host, $usr, $pass, $cport );
    $k->uploadFile( $ops, $r, $transname );

    my $dgtype = "string";
    if ($mds eq "ip") { $dgtype = "ip"; }
    my $r = runGenericCommand( "tmsh create sys file data-group /$part/$n type $dgtype source-path file://$transname" );
    if (defined( $r->{'commandResult'})) {
      print $tee "error while creating resource: " . $r->{'commandResult'};
      runGenericCommand( "rm $transname" );
      exit 1;
    }
    runGenericCommand( "rm $transname" );

    # create ltm link for an data-group
    my $z = {
      name      => $n,
      kind      => 'tm:ltm:data-group:external:externalstate',
      partition => $part,
      externalFileName => "/$part/$n"
    };
    my $ck = existsResource( "ltm/data-group/external/~$part~$n" );
    if ($ck) {
      return $ck;
    } else {
      return postRequest( $URL . 'ltm/data-group/external', $js->encode( $z ) );
    }
  }

  if ($t eq 'monitor') {
    my $transname = "/shared/tmp/tmp-auto-$n-" . $tmp_stmp;
    my $k = new CAudit( $host, $usr, $pass );
    $k->uploadFile( $ops, $r, $transname );

    my $r = runGenericCommand( "tmsh create sys file external-monitor /$part/$n source-path file://$transname" );
    if (defined( $r->{'commandResult'})) {
      print $tee "error while creating resource: " . $r->{'commandResult'};
      runGenericCommand( "rm $transname" );
      exit 1;
    }
    runGenericCommand( "rm $transname" );
  }

}

#
# check if given resource iCR path exists
# returns 0 or object
sub existsResource {
  my ($name) = @_;
  set_rflag('req_error_silent', 1);
  my $r = query2object( $URL . $name, 'do_not_fail' );
  set_rflag('req_error_silent', 0);
  if (defined $r->{'error'}){
    return 0;
  } else {
    return $r;
  }
}

#
# update resource: iRule|ifile,...
sub updateResource
{
  my ($t, $n, $part, $r, $ops) = @_;
  my $js = JSON->new;
  $js->pretty();

  if ($t eq 'rule') {
    open my $fh, "<", "$r" or terminate_with_error($tee, 'file open', "Error opening resource file: $r");
    read $fh, my $buffer, -s $fh;
    close $fh;
    my $z = {
      apiAnonymous => $buffer,
      partition => $part
    };
    return putRequest( $URL . 'ltm/rule/' . $n, $js->encode( $z ) );
  }

  if ($t eq 'ifile') {
    my $transname = "/shared/tmp/tmp-auto-$n-" . $tmp_stmp;
    my $k = new CAudit( $host, $usr, $pass, $cport );
    $k->uploadFile( $ops, $r, $transname );

    my $r = runGenericCommand( "tmsh modify sys file ifile /$part/$n source-path file://$transname" );
    if (defined( $r->{'commandResult'})) {
      printf $tee "error while updating resource: %s \n", $r->{'commandResult'};
      runGenericCommand( "rm $transname" );
      exit 1;
    }
    runGenericCommand( "rm $transname" );

    unless ( existsResource( "ltm/ifile/~$part~$n" ) ) {
      print $tee "error ltm ifile missing!";
      return 0;
    }

  }

  if ($t eq 'dgroup') {
    my $transname = "/shared/tmp/tmp-auto-$n-" . $tmp_stmp;
    my $k = new CAudit( $host, $usr, $pass, $cport );
    $k->uploadFile( $ops, $r, $transname );

    my $r = runGenericCommand( "tmsh modify sys file data-group /$part/$n source-path file://$transname" );
    if (defined( $r->{'commandResult'})) {
      print $tee "error while updating resource: " . $r->{'commandResult'};
      runGenericCommand( "rm $transname" );
      exit 1;
    }
    runGenericCommand( "rm $transname" );

    unless ( existsResource( "ltm/data-group/external/~$part~$n" ) ) {
      print $tee "error ltm dgroup external link is missing!";
      return 0;
    }
  }

  if ($t eq 'monitor') {
    my $transname = "/shared/tmp/tmp-auto-$n-" . $tmp_stmp;
    my $k = new CAudit( $host, $usr, $pass, $cport );
    $k->uploadFile( $ops, $r, $transname );

    my $r = runGenericCommand( "tmsh modify sys file external-monitor /$part/$n source-path file://$transname" );
    if (defined( $r->{'commandResult'})) {
      print $tee "error while updating resource: " . $r->{'commandResult'};
      runGenericCommand( "rm $transname" );
      exit 1;
    }
    runGenericCommand( "rm $transname" );
  }

}

#
# delete resource
sub deleteResource {
  my ($t, $n) = @_;
}

#
# verify if specified resource exists in F5's configuration
sub check_icr_path {
  my ($def, $opts) = @_;
  my $ldir = './js-store'; # directory to save backups
  my $cdir = 'js-templates';
  if (defined($opts->{'make_local_copy'}) and $opts->{'make_local_copy'}) {
    print $tee "  . saving resources into js-store \n";
    if (defined $opts->{'js-store-dir'}) {
      substr($ldir, 0, 1) = $opts->{'js-store-dir'};
    } else {
      substr($ldir, 0, 2) = $wDir;
    }
    unless (-e $ldir) {
      print $tee "  . creating local store: $ldir\n";
      mkdir $ldir;
    }
  }
  if (defined($def->{'type'} and defined($def->{'set'}))) {
    print $tee '-'x 110 . "\n";
    print $tee "  . processing verify category: \x1b[34m$def->{'type'}\x1b[0m\n";
    for my $item (sort @{ $def->{'set'} }) {
      my $verd = "\x1b[31mMISS\x1b[0m";
      my $extra = '';
      my $pa = "Common";
      if (defined($item->{'partition'})) {
        $pa = $item->{'partition'};
      }
      if (defined($item->{'app'})) {
        $pa .= "~$item->{'app'}";
      }
      my $r = existsResource( "$def->{'type'}/~$pa~$item->{'name'}" );
      if ($r) {
        $verd = "\x1b[32mFOUND\x1b[0m";
        if (defined($opts->{'make_local_copy'}) and $opts->{'make_local_copy'}) {
          # save resource
          if (defined $r->{'apiAnonymous'}) {
            open my $fh, ">", "$ldir/$pa" . "~$item->{'name'}" or terminate_with_error($tee, 'file create', "Cannot create resource dump file $pa");
            print $fh $r->{'apiAnonymous'};
            close($fh);
          } else {
            my $js = JSON->new;
            $js->pretty();
            $js->canonical();
            foreach my $z ( qw( defaultsFromReference generation kind selfLink appServiceReference) ) {
              delete $r->{$z};
            }
            my $data = $js->encode($r);
            open my $fh, ">", "$ldir/$pa" . "~$item->{'name'}" or terminate_with_error($tee, 'file create', "Cannot create resource dump file $pa");
            print $fh $data;
            close($fh);
          }
        }
        if (defined($opts->{"base_location"})) {
          if (defined $opts->{'js-template-dir'}) {
            $cdir = $opts->{'js-template-dir'};
          }
          my $localFile = $opts->{"base_location"} . "$cdir/$pa~" . $item->{'name'};
          if (-e $localFile) {
            # if template exists than compare
            my $l_ssha = get_file_sha1( $localFile, '' );
            my $buffer = '';
            if (defined $r->{'apiAnonymous'}) {
              $buffer = $r->{'apiAnonymous'};
            } else {
              my $js = JSON->new;
              $js->pretty();
              $js->canonical();
              foreach my $z ( qw( defaultsFromReference generation kind selfLink appServiceReference) ) { delete $r->{$z}; }
              $buffer = $js->encode($r);
            }
            my $r_ssha = sha1_hex( $buffer );
            if ($r_ssha eq $l_ssha) {
              $extra = "(verification::positive hash:$r_ssha)";
            } else {
              $extra = "(verification::failed hash local:$l_ssha remote:$r_ssha)";
              if (defined $opts->{'verify_diff'} and $opts->{'verify_diff'}) {
                my $fsd = get_file_content( $localFile );
                my $df = diff \$buffer, \$fsd, { STYLE => "Unified" };
                my @lines = split /[\n]/, $df;
                foreach my $l (@lines) {
                  if ($l =~ /^\-/) {
                    print $tee $l . "\n";
                  } elsif ($l =~ /^\@\@/) {
                    if ($^O eq "MSWin32") {
                      printf $tee "%s\n", $l;
                    } else {
                      printf $tee "\033[35m%s\033[0m\n", $l;
                    }
                  } else {
                    if ($^O eq "MSWin32") {
                      printf $tee "%s\n", $l;
                    } else {
                      printf $tee "\033[33m%s\033[0m\n", $l;
                    }
                  }
                }
              }
            }
          } else {
             printf ">>> not found: lc: %s \n", $localFile;
          }
        }
      }
      if (defined($item->{'app'})) {
        printf $tee "  %-32s: [%s] %s\n", "$item->{'app'}/$item->{'name'}", $verd, $extra;
      } else {
        printf $tee "  %-32s: [%s] %s\n", $item->{'name'}, $verd, $extra;
      }
    }
    print $tee '-'x 110 . "\n";
  } else {
    print $tee "error while processing verification set: ";
    exit 1;
  }
}

sub get_running_software
{
  my %p;
  my $r = query2object( $URL . 'sys/software/volume');
  foreach my $r ( @{ $r->{'items'} } ) {
    if ($r->{'active'}) {
      $p{'active volume'}  = $r->{'name'};
      $p{'soft version'} = $r->{'version'};
      $p{'soft build'}   = $r->{'build'};
    }
  }
  return %p;
}

sub getCwd {
  my $ret;
  if ($^O eq "MSWin32") {
    $ret = `cd`;
  } else {
    $ret = `pwd`;
  }
  chomp($ret);
  return $ret;
}

#
# check if we are dealing with parseable JSON string
sub isJSONString {
  my ($data) = @_;
  my $error = undef;
  {
    local $@;
    $error = $@ || 'Parse error' unless eval { decode_json($data) }
  }
  return (defined $error) ? 0 : 1;
}

#
# wait until some action happens
sub wait_for_api_event{
  my ($event, $timeout) = @_;
  unless ($timeout) {
    $timeout = 600; # 10 minutes default timeout
  }
  if ($event =~ /(online|standby|active)/) {
    # wait until box is standby or active
    print $tee ". waiting for device to become $event \n";
    my $stm = time();
    EWAIT: while ((time() - $stm) < $timeout) {
       print $tee '.';
       # check
       my $r = &query2object( $URL . 'cm/device', 'do_not_fail' );
       foreach my $e ( @{ $r->{'items'}} ) {
         if ($e->{'managementIp'} eq $host) {
           print " $e->{'failoverState'} ";
           if ($event eq 'online') {
             if ($e->{'failoverState'} =~ /(active|standby)/) { last 'EWAIT'; }
           } else {
             if ($e->{'failoverState'} eq $event) { last 'EWAIT'; }
           }
         }
       }
       # time check
       sleep(8);
    }
    my $delta = time() - $stm;
    print $tee "\n[ done ] waiting complete, time: $delta sec\n";
  }
}

#
# install update ilx worspaces from archive files (.xz)
sub load_ilx_workspace
{
  my ($df) = @_;
  my $k = new CAudit( $host, $usr, $pass, $cport );
  my $pa = 'Common';

  if (defined $df->{'ilx'} && defined $df->{'ilx'}{'workspaces'}) {
    my %wks  = %{ $df->{'ilx'}{'workspaces'} };
    foreach my $w (sort keys %wks) {
      if (defined $wks{$w}{'archive'}) {
        $k->uploadFile( $df->{'options'}, $wks{$w}{'archive'}, '/shared/tmp/' . $wks{$w}{'archive'} );
        print $tee ". installing workspace: $w: ";
        my $operation = 'create';
        if (existsResource( "ilx/workspace/~$pa~$w")) {
          print $tee " - updating - ";
          $operation = 'modify';
        }
        my $r = &runGenericCommand("tmsh $operation ilx workspace $w from-uri file:///shared/tmp/$wks{$w}{archive}");
        if (existsResource( "ilx/workspace/~$pa~$w")) {
          print $tee "[ \033[32mSUCCESS\033[0m ]\n";
        } else {
          print $tee "[ \033[31mFAILED\033[0m ] \n";
          print $tee Dumper( $r ) . "\n";
        }
      }
    }
  }
}

sub update_ilx_plug_ext_rd{
  my ($pa, $plug, $rd) = @_;
  my $r = query2object( $URL . "ilx/plugin/~$pa~$plug/extensions", 'do_not_fail' );
  if (defined $r->{items}) {
    foreach my $ptr (@{ $r->{items} }) {
      my $ext = $ptr->{name};
      my $js = JSON->new;
      my $z = {
        defaultRouteDomain => $rd
      };
      $js->pretty();
      my $res = patchRequest( $URL . "ilx/plugin/~$pa~$plug/extensions/$ext", $js->encode( $z ) );
      #print Dumper( $res );
    }
  }
}

#
# install update ilx worspaces from archive files (.xz)
sub load_ilx_plugins
{
  my ($df) = @_;
  my $pa = 'Common';

  if (defined $df->{'ilx'} && defined $df->{'ilx'}{'plugins'}) {
    my %pls  = %{ $df->{'ilx'}{'plugins'} };
    foreach my $w (sort keys %pls) {
      if (defined $pls{$w}{'workspace'}) {
        my $ws = $pls{$w}{'workspace'};
        my $rd = '0';
        my $desc = 'batch-loaded-plugin';
        my $publ = '';

        if (defined $pls{$w}{'partition'}) { $pa = $pls{$w}{'partition'} }
        if (defined $pls{$w}{'route-domain'}) { $rd = $pls{$w}{'route-domain'} }
        if (defined $pls{$w}{'description'}) { $desc = $pls{$w}{'description'} }
        if (defined $pls{$w}{'publisher'}) { $publ = $pls{$w}{'publisher'} }

        print $tee ". configuring plugin: $w: from workspace: /$pa/$ws";
        my $operation = 'create';
        if (existsResource( "ilx/plugin/~$pa~$w")) {
          print $tee " - updating - ";
          $operation = 'modify';
        }
        # REST operation
        my $js = JSON->new;
        my $z = {
          name          => $w,
          fromWorkspace => "/$pa/$ws",
          partition     => $pa,
          description   => $desc,
        };
        if ($publ ne '') {
          $z->{'logPublisher'} = $publ;
        }
        $js->pretty();
        my $res;
        if ($operation eq 'create') {
           $res = postRequest( $URL . 'ilx/plugin', $js->encode( $z ) );
        } else {
           $res = patchRequest( $URL . "ilx/plugin/~$pa~$w", $js->encode( $z ) );
        }
        #print Dumper( $res );
        # verification
        if (existsResource( "ilx/plugin/~$pa~$w")) {
          if ($rd ne '0') { update_ilx_plug_ext_rd( $pa, $w, $rd ) }
          print $tee "[ \033[32mSUCCESS\033[0m ]\n";
        } else {
          print $tee "[ \033[31mFAILED\033[0m ] \n";
        }
      }
    }
  }
}

sub parseVariables {
  my ($def) = @_;
  my %dict;
  foreach my $k ( split(',', uri_unescape($def)) ) {
    my ($p, $v) = split '=', $k;
    $dict{$p} = $v;
  }
  return \%dict;
}

#
# Batch mode to execute set of commands
# use -B to specify steset from a command line
# params:
#  input: file name or string with commands
#  mode: file or inline
sub batch_mode {
  my ($fn, $md) = @_;

  my $j = {
    options => { },
    steps => [],
    quiet => 0,
    vars => { },
  };

  if ($md eq 'file') {
    if (index($fn, "/") < 0 or substr($fn,0,2) eq "./") {
      # try local directory as path is not absolute
      $fn = "$rundir/$fn";
    }
    open my $fh, "<", "$fn" or terminate_with_error($tee, 'batch open', "error opening resource file: $fn");
    read $fh, my $buffer, -s $fh;
    close $fh;
    if (isJSONString($buffer)) {
      $j = decode_json($buffer);
    } else {
      my @basename = split /\//, $fn;
      terminate_with_error($tee, "batch parse", "json syntax error in the input file: $basename[$#basename]");
      exit 1;
    }
    # check if batch file has a requires section
    if (defined($j->{'requires'})) {
      if (defined($j->{'requires'}{'f5-cfg'})) {
        my $ours = int(join("", split(/\./, $version)));
        my $wants = int(join("", split(/\./, $j->{'requires'}{'f5-cfg'})));
        if ($ours < $wants) {
          terminate_with_error($tee, "batch requirements", "cannot continue as we need at leat version: $wants");
        }
      }
      if (defined($j->{'requires'}{'variables'})) {
        if (!$opts{'v'}) {
          terminate_with_error($tee, "batch variables", "variable definition missing and required by the batch file" );
        }
        $j->{'vars'} = parseVariables($opts{'v'});
        foreach my $keyName (@{ $j->{'requires'}{'variables'} }) {
          if (!defined($j->{vars}{$keyName})) {
            terminate_with_error($tee, "batch variables", "variable $keyName is not defined" );
          } else {
            $buffer =~ s/\(\($keyName\)\)/$j->{vars}{$keyName}/g;
          }
        }
        # reload the batch json
        if (isJSONString($buffer)) {
          $j = decode_json($buffer);
        } else {
          terminate_with_error($tee, "batch parse", "json syntax error, after variable expansion");
          exit 2;
        }
      }
    }
  } elsif ($md eq 'inline') {
    my @st = split(';', $fn);
    $j->{'steps'} = \@st;
  } else {
    terminate_with_error($tee, 'batch mode', "unsupported batch mode requested: $md");
  }

  my $confNo  = 0;
  my $tmsh_mg = 0;
  my $file_mg = 0;
  my $cmd_mg = 0;
  my $alternativeHost = '';

  # this is for extended tests
  $j->{'options'}{'rundir'} = $rundir;

  # json encoding
  if ($opts{J}) { $j->{options}{encoding} = 'json'; }

  # quiet mode for batch
  if ($opts{Q}) { $j->{quiet} = 1; }

  # options parsing
  if (defined $j->{'options'}{'working-directory'}) {
    $wDir = $j->{'options'}{'working-directory'};
    if ($wDir eq '') {
      # we cannot continue at that moment
      terminate_with_error($tee, 'batch open', "working directory is empty!");
    }
    if (substr($wDir, 0, 2) eq "./") {
      substr($wDir, 0, 1) = $rundir;
    }
    $wDir .= '/';
    $wDir =~ s/\/\//\//g;
  } else {
    $j->{'options'}{'working-directory'} = $rundir . '/';
    $wDir = $rundir . '/';
  }

  # base location fixup for relative paths
  if (defined $j->{'options'}{'base_location'}) {
    if (substr($j->{'options'}{'base_location'}, 0, 2) eq "./") {
      substr($j->{'options'}{'base_location'}, 0, 1) = $rundir;
    }
    $j->{'options'}{'base_location'} .= '/';
    $j->{'options'}{'base_location'} =~ s/\/\//\//g;
  } else {
    $j->{'options'}{'base_location'} = $rundir . '/';
  }

  # iRules location pathing
  if (defined $j->{'options'}{'rules_location'}) {
    if (substr($j->{'options'}{'rules_location'}, 0, 2) eq "./") {
      substr($j->{'options'}{'rules_location'}, 0, 1) = $rundir;
    }
  } else {
    $j->{'options'}{'rules_location'} = $rundir . '/';
  }

  if (not (defined $j->{options}{encoding})) {
    print $tee "+ final batch workdir: $wDir\n";
    print $tee "+ final batch basedir: $j->{options}{base_location}\n";
    print $tee "+ final batch ruledir: $j->{options}{rules_location}\n";
    print $tee "+ batch output encoding: $j->{options}{encoding}\n";
  }

  #verify system matches description
  if (defined ($j->{'system-ip'}) and ($j->{'system-ip'} ne "*")) {
    if ($host !~ /$j->{'system-ip'}/) {
      print $tee "(error) management IP address does not match\n";
      return;
    }
  }
  my $rsw = $srun{'soft version'} . "." . $srun{'soft build'};
  if (defined ($j->{'sw-version'}) and ($j->{'sw-version'} ne "*")) {
    if ($rsw !~ /$j->{'sw-version'}/) {
      print $tee "(error) running software: $rsw does not match requested: $j->{'sw-version'}\n";
      return;
    }
  }

  if ((defined $j->{'description'}) and (!$j->{quiet})) {
    printf $tee "\x1b[7m<batch version=\"%s\" author=\"%s\">\n", $j->{'version'}, $j->{'author'};
    print  $tee "  batch provided for: $j->{'system-ip'}\n";
    print  $tee "  description: $j->{'description'}\n";
    print  $tee "  software: $j->{'sw-version'}\n";
    print  $tee "<\\batch>\x1b[0m\n";
  }

  my $pxstep = $j->{'steps'};
  if (($bstep ne "") and (defined $j->{'stepset'})) {
    if (defined $j->{'stepset'}{$bstep}) {
      if (!$j->{quiet}) { print $tee "+-- loading step set: $bstep\n"; }
      $pxstep = $j->{'stepset'}{$bstep};
    } else {
      print $tee "-- failed to find a step set: $bstep\n";
    }
  }

  # execute a batch
  foreach my $step ( @{ $pxstep } ) {
    # special targets
    my @otgt = split( ':', $step);
    my $cindex = 0;
    my $cabrt = 1;
    if ($#otgt >= 1) {
      switch ($otgt[0]) {
        case 'DELAY' {
          sleep($otgt[1]);
        }
        case 'WAIT_FOR' {
          if (!$j->{quiet}) { print $tee "+-- [step: $otgt[0]] pause batch until the event: $otgt[1]\n"; }
          wait_for_api_event( $otgt[1] );
        }
        case 'USE_HOST' {
          if ($otgt[1] =~ /^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$/) {
            if ($otgt[1] ne $host) {
              if (!$j->{quiet}) { print $tee "+ switching host from: $host to: \033[35m$otgt[1]\033[0m\n "; }
              $alternativeHost = $host;
              &update_host( $otgt[1] );
            }
          } else {
            terminate_with_error($tee, 'USE_HOST', "invalid IP address in a switch host directive. Cannot continue as we may destroy something");
          }
        }
        case 'UPSET' {
          if ((defined $j->{'uploadset'}) && (defined $j->{'uploadset'}{$otgt[1]})) {
            foreach my $kx ( @{ $j->{'uploadset'}{$otgt[1]} }) {
              my $ksrc;
              if (index($kx,'|')>=0) {
                my @at = split('|', $kx);
                $kx = $at[0];
                $ksrc = $at[1];
              } else {
                $ksrc = parseFileToken($kx);
              }
              if (!$j->{quiet}) { print $tee "+-- [step: $step] uploading object: $kx from $ksrc\n"; }
              if (defined $j->{'options'}{'base_location'}){
                my $k = new CAudit( $host, $usr, $pass, $cport );
                $k->uploadFile( $j->{'options'}, $ksrc, $kx );
              }
            }
          }
        }
        case 'CSET' {
          if (!$j->{quiet}) { print $tee "+-- [step: $otgt[0]] command set execute: $otgt[1]\n"; }
          if ((defined $j->{'commandset'}) && (defined $j->{'commandset'}{$otgt[1]})) {
            foreach my $kx ( @{ $j->{'commandset'}{$otgt[1]} }) {
              if (!$j->{quiet}) { print $tee "   . executing command: \x1b[32m$kx\x1b[0m\n"; }
              my $r = runGenericCommand( $kx );
              if (defined $r->{'commandResult'}){
                printf $tee "  . (!!) unexpected command result: %s", $r->{'commandResult'};
              }
            }
          }
        }
        case 'DSET' {
          if (!$j->{quiet}) { print $tee "+-- [step: $otgt[0]] download set execute: $otgt[1]\n"; }
          if ((defined $j->{'downloadset'}) && (defined $j->{'downloadset'}{$otgt[1]}) && (defined $j->{'options'}{'store_location'})) {
            my $k = new CAudit( $host, $usr, $pass, $cport );
            foreach my $kx ( @{ $j->{'downloadset'}{$otgt[1]} }) {
              if (!$j->{quiet}) { print $tee "   . retrieve file: \x1b[32m$kx\x1b[0m\n"; }
              $k->downloadResource($j->{'options'}, 'file', $kx, $j->{'options'}{'store_location'} . '/' . parseFileToken($kx) );
            }
          }
        }
        case 'RSET' {
          if (!$j->{quiet}) { print $tee "+-- [step: $step] updating a set of irules: $otgt[1]\n"; }
          if ((defined $j->{'ruleset'}) && (defined $j->{'ruleset'}{$otgt[1]})) {
            load_irules( $j, $otgt[1] );
          }
        }
        case 'MSET' {
          if (!$j->{quiet}) { print $tee "+-- [step: $step] merging tmsh config file set: $otgt[1]\n"; }
          if ((defined $j->{'mergeset'}) && (defined $j->{'mergeset'}{$otgt[1]})) {
            foreach my $kx ( @{ $j->{'mergeset'}{$otgt[1]} }) {
              if (defined $j->{'options'}{'base_location'}) {
                if (!$j->{quiet}) { print $tee "  . \x1b[34mmerging file: $kx\x1b[0m\n"; }
                my $k = new CAudit( $host, $usr, $pass, $cport );
                $k->uploadFile( $j->{'options'}, parseFileToken($kx), $kx );
              }
              if (defined($j->{'options'}{'verify_merge_sets'})) {
                my $r = verifyMergeFile( $kx );
                if ($r ne 'OK') {
                  printf $tee "-- merge stopped due to a verification failure: \033[31m%s\033[0m\n", $r;
                  exit 1;
                } else {
                  loadMergeFile( $kx );
                }
              } else {
                loadMergeFile( $kx );
              }
            }
          }
        }
        case 'VERIFY_SET' {
          if (!$j->{quiet}) { print $tee "+-- [step: $step] processing verification set: $otgt[1]\n"; }
          if ((defined $j->{'verifyset'}) && (defined $j->{'verifyset'}{$otgt[1]})) {
            foreach my $kx ( @{ $j->{'verifyset'}{$otgt[1]} }) {
              # kx is an object: type - icr path,  set - list of items to check
              check_icr_path( $kx, $j->{'options'} );
            }
          }
        }
        case 'GET_ZONE_INFO' {
          my $view = $otgt[2] || 'external';
          my $zone = $otgt[1];
          if ((defined $j->{options}{encoding}) && ($j->{options}{encoding} eq 'json')) {
            my $k = new CAudit( $host, $usr, $pass, $cport );
            my $zs = $k->getZoneInfo($view, $zone);
            my $js = JSON->new;
            my $r = generate_JSON_response({ view => $view, zone => $zone });
            $js->pretty();
            $r->{response} = { };
            foreach my $prop (sort keys %{ $zs->[0] }) {
              if ($prop eq 'zone_file') {
                my $zfn = $zs->[0]{$prop};
                $zfn =~ s/\"//g;
                $r->{response}{$prop} = "/var/named/config/namedb/$zfn";
              } else {
                $r->{response}{$prop} = $zs->[0]{$prop};
              }
            }
            print $tee $js->encode($r)
          } else {
            if (!$j->{quiet}) { print $tee "+-- [step: $step] geting ZoneRunner zone information: $view/$zone\n"; }
            my $k = new CAudit( $host, $usr, $pass, $cport );
            my $zs = $k->getZoneInfo($view, $zone);
            print $tee "zone \033[32m$zone\033[0m properties in view: \033[32m$view\033[0m\n";
            foreach my $prop (sort keys %{ $zs->[0] }) {
              if ($prop eq 'option_seq') {
                my $seqs = join(@{ $zs->[0]{$prop} }, ' ');
                print $tee "  $prop: $seqs\n";
              } else {
                print $tee "  $prop: $zs->[0]{$prop}\n";
              }
            }
          }
        }
        case 'GET_ZONE_RRS' {
          my $view = $otgt[2] || 'external';
          my $zone = $otgt[1];
          if ((defined $j->{options}{encoding}) && ($j->{options}{encoding} eq 'json')) {
            my $k = new CAudit( $host, $usr, $pass, $cport );
            my $zs = $k->getZoneRecords($view, $zone);
            my $js = JSON->new;
            my $r = generate_JSON_response({ view => $view, zone => $zone });
            my @items;
            $js->pretty();
						$js->canonical(1);

            foreach my $rec (sort @{ $zs->[0] }) {
              push @items, $rec;
            }

            $r->{items} = \@items;
            print $tee $js->encode($r)
          } else {
            if (!$j->{quiet}) { print $tee "+-- [step: $step] geting ZoneRunner rrs information: $view/$zone\n"; }
            my $k = new CAudit( $host, $usr, $pass, $cport );
            my $zs = $k->getZoneRecords($view, $zone);
            print $tee "zone \033[32m$zone\033[0m properties in view: \033[32m$view\033[0m\n";
            foreach my $rec (sort @{ $zs->[0] }) {
              print $tee "  $rec\n";
            }
          }
        }
        case 'ADD_ZONE_A' {
          # params: zone:view:name:ip:ttl
          my $zone = $otgt[1];
          my $view = $otgt[2];
          my $ttl = $otgt[5] || 0;
          if (!$j->{quiet}) { print $tee "+-- [step: $step] adding record of type A to ZoneRunner: $view/$zone\n"; }
          my $k = new CAudit( $host, $usr, $pass, $cport );
          my @rrs = qw();
          push @rrs, { domain_name => $otgt[3], ip_address => $otgt[4], ttl => $ttl };
          my $zs = $k->processZoneRecord('create', $view, $zone, 'A', \@rrs );
          print $tee "result: $zs\n";
        }
        case 'DEL_ZONE_A' {
          # params: zone:view:name:ip:ttl
          my $zone = $otgt[1];
          my $view = $otgt[2];
          my $ttl = $otgt[5] || 0;
          if (!$j->{quiet}) { print $tee "+-- [step: $step] removing record of type A from ZoneRunner: $view/$zone\n"; }
          my $k = new CAudit( $host, $usr, $pass, $cport );
          my @rrs = qw();
          push @rrs, { domain_name => $otgt[3], ip_address => $otgt[4], ttl => $ttl };
          my $zs = $k->processZoneRecord('delete', $view, $zone, 'A', \@rrs );
          print $tee "result: $zs\n";
        }
        case 'ZRSET' {
          my $err = '';
          my @results = qw();
          my $complete = 1;
          if (!$j->{quiet}) { print $tee "+-- [step: $step] processing ZoneRunner set: $otgt[1]\n"; }
          if ((defined $j->{'zoneset'}) && (defined $j->{'zoneset'}{$otgt[1]})) {
            my $k = new CAudit( $host, $usr, $pass, $cport );
            my $idx = 1;
            #
            # Processing
            #
            if (exists $j->{'zoneset'}{$otgt[1]}) {
              # verification : pass 1
              foreach my $kx ( @{ $j->{'zoneset'}{$otgt[1]} }) {
                if (exists($kx->{'type'}) and exists($kx->{'view'}) and exists($kx->{'db'})) {
                  if (exists($kx->{'items'}) and exists($kx->{'class'})) {
                    # zone records can be given in a form of a file
                  } elsif (exists($kx->{'itemSource'}) and ($kx->{'itemSource'} ne '')) {
                    # items in a separate file
                  } else {
                    $err = 'resource records not specified';
                    last;
                  }
                } else {
                  $err = 'invalid syntax';
                  last;
                }
              }
              if ($err eq '') {
                # executing : pass 2
                foreach my $kx ( @{ $j->{'zoneset'}{$otgt[1]} }) {
                  if (!$j->{quiet}) { print $tee ">>>> opset [$idx] ctype: \033[35m$kx->{type}\033[0m\n"; }
                  if (exists($kx->{'type'}) and exists($kx->{'view'}) and exists($kx->{'db'})) {
                    if (exists($kx->{'items'}) and exists($kx->{'class'})) {
                      # items in a table and confined to given record type
                      my $result = $k->processZoneRecord($kx->{'type'}, $kx->{'view'}, $kx->{'db'}, $kx->{'class'}, $kx->{'items'});
                      if (!$j->{quiet}) { print $tee "  . --> $result\n"; }
                      push @results, { type => $kx->{type}, zone => $kx->{db}, class => $kx->{class}, result => $result };
                      if ($result ne 'done') { $complete = 0; }
                      $idx++;
                    }
                    elsif (exists($kx->{'itemSource'}) and ($kx->{'itemSource'} ne '')) {
                      my $js = parseJsonFile($j->{'options'}, $kx->{'itemSource'});
                      foreach my $rtype (keys %{ $js->{'records'} }) {
                        my $nrec = scalar @{ $js->{records}{$rtype} };
                        if ($nrec > 0) {
                          if (!$j->{quiet}) { print $tee "  . processing records: $rtype $nrec\n"; }
                          my $result = $k->processZoneRecord($kx->{'type'}, $kx->{'view'}, $kx->{'db'}, uc($rtype), $js->{'records'}{$rtype});
                          if (!$j->{quiet}) { print $tee "  . ($rtype)--> $result\n"; }
                          push @results, { type => $kx->{type}, zone => $kx->{db}, source => $kx->{itemSource}, result => $result };
                          if ($result ne 'done') { $complete = 0; }
                        }
                      }
                      $idx++;
                    }
                  }
                }
              }
            } else {
              $err = 'zrset definition missing';
            }
          }
          #
          # reporting
          #
          if ((defined $j->{options}{encoding}) && ($j->{options}{encoding} eq 'json')) {
            my $r = generate_JSON_response({ context => 'zrset' });
            my $js = JSON->new;
            $js->pretty();
            if ($err ne '') {
              $r->{error} = $err;
            } else {
              $r->{items} = \@results;
            }
            $r->{result} = ($complete) ? 'success' : 'failed';
            print $tee $js->encode($r)
          } else {
            if ($err ne '') {
              print $tee "\033[31m!malformed zoneset definition found ($err)! \033[0m\n";
            } else {
              print $tee ">>>> complete \n";
            }
          }
        }
        case 'DON_PROVISION' {
          print $tee "+-- [step: $step] processing declarative onboarding set: $otgt[1]\n";
          if ((defined $j->{'clusterset'}) && (defined $j->{'clusterset'}{$otgt[1]})) {
            my $fn = $j->{'options'}{'base_location'} . $j->{'clusterset'}{$otgt[1]}{'resource'};
            my $hs = $j->{'clusterset'}{$otgt[1]}{'host'};

            open my $fh, "<", $fn or terminate_with_error($tee, 'file open', "--- Error opening resource file: $fn");
            read $fh, my $buffer, -s $fh;
            close $fh;

            my $dur = $URL;
            $dur =~ s/tm\///;
            my $res = postRequest( $dur . 'shared/declarative-onboarding?async=true', $buffer);
            my $tid = '';
            print Dumper($res) . "\n";

            if (ref($res) eq 'HASH' && defined $res->{'id'}) {
              $tid = $res->{'id'};
            } else {
              terminate_with_error($tee, 'DON_PROVISION', "problem with starting a do process");
            }

            # wait for task to finish
            print $tee ". waiting for do process: $tid to finish\n";
            while (1) {
              $res = query2object( $dur . 'shared/declarative-onboarding/task/' . $tid, 'do_not_fail' );
              if (ref($res) eq 'HASH') {
                if (defined $res->{'result'} && $res->{'result'}{'status'} eq 'OK') {
                  print $tee "+ declarative onboarding is now installed, version:\033[32m $$res[0]{'version'}\033[0m\n";
                  last;
                }
                if (defined $res->{'result'} && $res->{'result'}{'status'} eq 'ERROR') {
                  print $tee "-- do failed with error: $res->{'result'}{'message'}\n";
                  exit 7;
                }
              }
              sleep 2;
            }

          }
        }
        default {
          $cabrt = 0;
        }
      }
      next if $cabrt;
    }
    # normal targets
    switch ($step) {
      case 'RESTART' {
        print $tee "+-- [step: $step] restarting tmos processes\n";
        set_rflag('req_not_fatal', 1);
        set_rflag('req_error_silent', 1);
        &runGenericCommand('clsh bigstart restart');
        set_rflag('req_not_fatal', 0);
        set_rflag('req_error_silent', 0);
      }
      case 'REBOOT' {
        print $tee "+-- [step: $step] rebooting node (blades)\n";
        set_rflag('req_not_fatal', 1);
        set_rflag('req_error_silent', 1);
        &runGenericCommand('clsh reboot');
        set_rflag('req_not_fatal', 0);
        set_rflag('req_error_silent', 0);
      }
      case 'MCPD_FORCELOAD' {
        print $tee "+-- [step: $step] flagging mcpd resync: procedure K13030\n";
        &runGenericCommand('clsh touch /service/mcpd/forceload');
      }
      case 'RESET_HOST' {
        print $tee ". switching target back to: $alternativeHost\n";
        &update_host( $alternativeHost );
        $alternativeHost = '';
      }
      case 'COMPARE_DBSET' {
        print $tee "+-- [step: $step] comparing sys variables\n";
        report_dbvars( $j->{'dbvars'} );
      }
      case 'COMPARE_RULES' {
        print $tee "+-- [step: $step] comparing irule codebase\n";
        report_irules($j->{'options'}{'rules_location'}, ($j->{'options'}{'irule_diff'}) ? 'true' : 'false', $j);
      }
      case 'COMPARE_RSETS' {
        print $tee "+-- [step: $step] comparing irule codebase in sets\n";
        foreach my $setname (sort keys %{ $j->{'ruleset'} }) {
          print $tee "\033[35m>> comparing irules in the set: $setname\033[0m\n";
          report_irules($j->{'options'}{'rules_location'}, ($j->{'options'}{'irule_diff'}) ? 'true' : 'false', $j, $setname);
        }
      }
      case 'LOAD_ILX' {
        # load ILX workspace from an archive file
        print $tee "+-- [step: $step] install workspaces from an archive\n";
        load_ilx_workspace($j);
      }
      case 'LOAD_ILX_PLUGIN' {
        # load ILX workspace from an archive file
        print $tee "+-- [step: $step] configure ilx plugins\n";
        load_ilx_plugins($j);
      }
      case 'MAKE_UCS' {
        # Note: since 12.1.0 you need to perform all operations using iControl or iControlREST
        # ucs files created via REST is not available to iControl
        print $tee "+-- [step: $step] make system archive\n";
        #my $js = JSON->new;
        my $faName = "migrate-auto-${host_name}-${tmp_stmp}";
        if ($Label ne '') {
          $faName = "migrate-auto-${Label}-${host_name}_${tmp_stmp}";
        }
        my $z = {
          command => "save",
          name => $faName
        };
        if (defined $j->{'options'}{'ucs-file-name'}) {
           $z->{'name'} = $j->{'options'}{'ucs-file-name'} . "-" . ${tmp_stmp};
           print $tee "+-- setting ucs name to: $z->{'name'}";
        }
        my $k = new CAudit( $host, $usr, $pass, $cport );
        my $passw = '';
        if (defined $j->{'options'}{'ucs-secret'} and $j->{'options'}{'ucs-secret'} ne "") { $passw = $j->{'options'}{'ucs-secret'} }
        if ($popts->get('ucs_secret') ne '') { $passw = $popts->get('ucs_secret'); }
        if ($passw ne '') {
          print $tee "  . \033[34mcreating encrypted ucs archive\033[0m\n";
          $k->createUcs( $z->{name}, $passw );
        } else {
          $k->createUcs( $z->{name} );
        }
        print $tee "  . ucs saved into: $z->{name}\n";
        if ($wDir ne '') {
          $k->downloadResource($j->{'options'}, 'ucs', $z->{name} . ".ucs", $wDir . $z->{name} . ".ucs" );
        } else {
          print $tee "+-- note: working dir is not set, we do not download ucs!\n";
        }
        if ((defined $j->{'options'}{'remove_created_ucs'}) && ($j->{'options'}{'remove_created_ucs'} eq 'yes')) {
          # cleanup
          print $tee "  . removing ucs we have created\n";
          $k->deleteResource( $z->{name} . '.ucs', 'ucs' );
        }
      }
      case 'MAKE_SCF' {
        print $tee "+-- [step: $step] make system scf archive\n";
        my $k = new CAudit( $host, $usr, $pass, $cport );
        my $fname = "migrate-auto-${host_name}-${tmp_stmp}.scf";
        if (defined $j->{'options'}{'scf-file-name'}) {
          $fname = $j->{'options'}{'scf-file-name'} . "-" . ${tmp_stmp};
          print $tee "+-- setting scf name to: $fname";
        }
        print $tee ":: saving files to: $wDir\n";
        if ((defined $j->{'options'}{'scf_via_rest'}) && ($j->{'options'}{'scf_via_rest'} eq 'yes')) {
          my $js = JSON->new;
          my $z = {
            command => "save",
            options => [
              {
                file            => $fname,
                "no-passphrase" => ""
              }
            ]
          };
          $js->pretty();
          my $res = postRequest( $URL . 'sys/config', $js->encode( $z ) );
        } else {
          my $passw = '';
          if (defined $j->{'options'}{'scf-secret'} and $j->{'options'}{'scf-secret'} ne "") { $passw = $j->{'options'}{'scf-secret'} }
          if ($popts->get('scf_secret') ne '') { $passw = $popts->get('scf_secret'); }
          if ($passw ne '') {
            print $tee "  . \033[34mcreating encrypted scf archive\033[0m\n";
            $k->createScf( $fname, $passw );
          } else {
            $k->createScf( $fname );
          }
        }
        if ($wDir ne '') {
          $k->downloadResource($j->{'options'}, 'file', "/var/local/scf/" . $fname, $wDir . $fname );
          $k->downloadResource($j->{'options'}, 'file', "/var/local/scf/" . $fname . ".tar", $wDir . $fname . ".tar" );
        } else {
          print $tee "+-- note: working dir is not set, we do not download scf!\n";
        }
        if ((defined $j->{'options'}{'remove_created_scf'}) && ($j->{'options'}{'remove_created_scf'} eq 'yes')) {
          # cleanup
          print $tee "  . removing scf files we have created\n";
          $k->deleteResource( $fname, 'scf');
        }
      }
      case 'LOAD_DEFAULT' {
         print $tee "+-- [step: $step] loading configuration defaults\n";
         my $r = runGenericCommand( 'tmsh load sys config default' );
         if (defined $r->{'commandResult'}){
            printf $tee "  . (!!) unexpected command result: %s", $r->{'commandResult'};
         }
      }
      case 'DON_CHECK' {
         print $tee "+-- [step: $step] checking declarative onboarding\n";
         my $dur = $URL;
         $dur =~ s/tm\///;
         my $res = query2object( $dur . 'shared/declarative-onboarding/info', 'do_not_fail' );
         #print Dumper($res);
         if (ref($res) eq 'HASH' && defined $res->{'error'}) {
           print $tee "- \033[31mdeclarative onboarding is not installed\033[0m\n";
           if ((defined $j->{'options'}{'install_do_package'}) && ($j->{'options'}{'install_do_package'}) && (defined $j->{'options'}{'declonboard_image'})) {
             my $ps = $j->{'options'}{'declonboard_image'};
             print $tee ". installing declarative onboarding package \033[33m$ps\033[0m\n";
             my $k = new CAudit( $host, $usr, $pass, $cport );
             #$k->uploadFile( $j->{'options'}, $ps, '/var/config/rest/downloads/' .  $ps);
             my $z = {
               operation => 'INSTALL',
               packageFilePath => '/var/config/rest/downloads/' . $ps
             };
             my $js = JSON->new;
             postRequest( $dur . 'shared/iapp/package-management-tasks', $js->encode( $z ));
             # wait for task to finish
             print $tee ". waiting for install process to finish\n";
             while (1) {
               $res = query2object( $dur . 'shared/declarative-onboarding/info', 'do_not_fail' );
               if (ref($res) ne 'HASH') {
                 if (defined $$res[0]{'version'}) {
                   print $tee "+ declarative onboarding is now installed, version:\033[32m $$res[0]{'version'}\033[0m\n";
                   last;
                 }
               }
               sleep 2;
             }
           } else {
             print $tee "-- \033[31mDeclarative onboarding extension is missing, we have to abort!\033[0m\n";
             exit 3;
           }
         } else {
           my $cver = $$res[0]{'version'};
           print $tee "+-- \033[34mDeclarative onboarding is installed, version: \033[32m$cver\033[0m\n";
         }
      }
      case 'LOAD_RULES' {
         print $tee "+-- [step: $step] load iRules on a system\n";
         load_irules( $j );
      }
      case 'UNBIND_VS' {
         print $tee "+-- [step: $step] unbind iRules from vs on a system\n";
         my $z = {
           rules => []
         };
         foreach my $rs ( @{ $j->{'unbindvs'}} ) {
           my $js = JSON->new;
           $js->pretty();
           print $tee "  . updating virtual server: $rs\n";
           if (index($rs,"/") > -1){
             $rs =~ tr/\//~/;
           }
           #print Dumper( $z );
           putRequest( $URL . 'ltm/virtual/' . $rs, $js->encode( $z ) );
         }
      }
      case 'REBIND_VS' {
         print $tee "+-- [step: $step] rebind iRules on a virtual server\n";
         my $z = {
           rules => []
         };
         foreach my $rs (sort keys %{ $j->{'virtuals'}}) {
           my $js = JSON->new;
           $js->pretty();
           if (ref($j->{'virtuals'}{$rs}) eq "ARRAY") {
             $z->{'rules'} = $j->{'virtuals'}{$rs};
           } else {
             $z->{'rules'} = $j->{'virtuals'}{$rs}{'rules'};
             if (defined($j->{'virtuals'}{$rs}{'site'})){
               my $sk = $j->{'virtuals'}{$rs}{'site'};
               unless ($host_name =~ /^$sk/) {
                 next;
               }
             }
           }
           print $tee "  . updating virtual server: $rs\n";
           if (index($rs,"/") > -1){
             $rs =~ tr/\//~/;
           }
           #print Dumper( $z );
           if ($srun{'soft version'} =~ /^12/) {
             patchRequest( $URL . 'ltm/virtual/' . $rs, $js->encode( $z ) );
           } else {
             putRequest( $URL . 'ltm/virtual/' . $rs, $js->encode( $z ) );
           }
         }
      }
      case 'DELETIONS' {
         print $tee "+-- [step: $step] delete specified resources\n";
         # remove priorities first
         foreach my $r (sort keys %{ $j->{'delete'} }) {
           if ($j->{'delete'}{$r}[1] == 1) {
             my $prt = $j->{delete}{$r}[2] || "Common";
             printf $tee "  . removing priority object: %-52s  [", "/$prt/$r";
             if (deleteRequest( $URL . $j->{'delete'}{$r}[0] . "/~$prt~" . $r ) == 0) {
               print $tee "SUCCESS]\n";
             } else {
               print $tee "FAILED]\n";
             }
           }
         }
         # remove other items
         foreach my $r (sort keys %{ $j->{'delete'} }) {
           if ($j->{'delete'}{$r}[1] != 1) {
             my $prt = $j->{delete}{$r}[2] || "Common";
             printf $tee "  . removing normal object: %-52s  [", "/$prt/$r";
             if (deleteRequest( $URL . $j->{'delete'}{$r}[0] . "/~$prt~" . $r ) == 0) {
               print $tee "SUCCESS]\n";
             } else {
               print $tee "FAILED]\n";
             }
           }
         }
         # done
      }
      case 'RECERT' {
        print $tee "+-- [step: $step] recertify iRules\n";
        my $crt = $j->{'options'}{'signing_key'};
        print $tee "+-- using key: $crt\n";
        foreach my $r (sort keys %{ $j->{'rules'} }) {
          print $tee "  . processing iRule: $r\n";
          my $js = JSON->new;
          my $z = {
            command => 'generate',
            name    => $r,
            options => [
              {
                 signature => $r,
              }
            ],
            'signing-key' => $crt
          };
          $js->pretty();
          postRequest( $URL . "ltm/rule", $js->encode( $z ));
        }
      }
      case 'RENAME' {
        print $tee "+-- [step: $step] renaming objects\n";
        foreach my $rc (sort keys %{ $j->{'rename'} }) {
          print $tee "  . renaming $rc --> $j->{rename}{$rc}\n";
          my $js = JSON->new;
          my $z = {
            command => 'mv',
            name    => $rc,
            target  => $j->{'rename'}{$rc},
          };
          $js->pretty();
          postRequest( $URL . "ltm/virtual", $js->encode( $z ));
        }
      }
      case 'ABORT' {
        print $tee "+-- [step: $step] aborting batch\n";
        exit;
      }
      case 'VERIFY' {
        print $tee "+-- [step: $step] verifying batch feasibility\n";
        print $tee "  . veryfying existence of objects: vs\n";
        my %oDone = qw||;
        #
        # bind rules (only virtuals)
        foreach my $ob (sort keys %{ $j->{virtuals} }) {
          if (defined $j->{rename}) {
            foreach my $rn (sort keys %{ $j->{rename} }) {
              if ($j->{rename}{$rn} eq $ob){
                $ob = $rn;
                last;
              }
            }
          }
          print "   -> $ob    ";
          if (index($ob,"/") > -1){
            $ob =~ tr/\//~/;
          }
          if (query2object( $URL . "ltm/virtual/" . $ob) == 2){
             print $tee  "\[FAILED]\n -- ABORTED -- \n";
             exit;
           } else {
             print $tee "\[SUCESS]\n";
             $oDone{$ob} = 1;
           }
        }
        #
        # unbinding rules
        foreach my $ob (@{ $j->{unbindvs} }) {
          if (not defined $oDone{$ob}) {
            print $tee "   -> $ob    ";
            if (index($ob,"/") > -1){
              $ob =~ tr/\//~/;
            }
            if (query2object( $URL . "ltm/virtual/" . $ob) == 2){
               print $tee  "\[FAILED]\n -- ABORTED --\n";
               exit;
             } else {
               print $tee "\[SUCESS]\n";
             }
          }
        }
        #
        # deleted objects
        print $tee "  . looking for deleted objects \n";
        foreach my $ob (sort keys %{ $j->{delete} }) {
           print $tee "   -> $ob    ";
           my $prt = $j->{delete}{$ob}[2] || "Common";
           if (query2object( $URL . $j->{delete}{$ob}[0] . "/~$prt~" . $ob) == 2){
             print $tee "\[NOT FOUND]\n -- ABORTED -- \n";
             exit;
           } else {
             print $tee "\[SUCESS]\n";
           }
        }
      }
      case 'CONFIRM' {
         if (defined $j->{'confirm-msg'}) {
           if ($cindex) {
             print $tee ">>>>> $j->{'confirm-msg'}[$cindex - 1]";
           } else {
             print $tee ">>>>> $j->{'confirm-msg'}[$confNo]";
             $confNo++;
           }
         } else {
           print $tee ">>>>> Please confirm to proceed ....";
         }
         readline;
      }
      case 'SAVE' {
        print $tee "+-- [step: $step] saving running configuration\n";
        saveRunConfig;
      }
      case 'SYNC' {
        print $tee "+-- [step: $step] syncing cluster configuration\n";
        if (defined $props{'failover cluster'}) {
          print $tee "  . synchronizing configuration of the cluster: $props{'failover cluster'}...\n";
          syncCluster( $props{'failover cluster'} );
        }
      }
      case 'LOADTMSH' {
        if (defined $j->{'tmsh-merge'}) {
          print $tee "+-- [step: $step] merging tmsh config file: $j->{'tmsh-merge'}[$tmsh_mg]\n";
          if (defined $j->{'options'}{'base_location'}){
            my $k = new CAudit( $host, $usr, $pass, $cport );
            $k->uploadFile( $j->{'options'}, parseFileToken($j->{'tmsh-merge'}[$tmsh_mg]), $j->{'tmsh-merge'}[$tmsh_mg] );
          }
          my $r = loadMergeFile( $j->{'tmsh-merge'}[$tmsh_mg] );
          $tmsh_mg++;
        }
      }
      case 'UPLOAD' {
        if (defined $j->{'upload'}) {
          print $tee "+-- [step: $step] uploading object: $j->{'upload'}[$file_mg]\n";
          if (defined $j->{'options'}{'base_location'}){
            my $k = new CAudit( $host, $usr, $pass, $cport );
            $k->uploadFile( $j->{'options'}, parseFileToken($j->{'upload'}[$file_mg]), $j->{'upload'}[$file_mg] );
          }
          $file_mg++;
        }
      }
      case 'COMMAND' {
        if (defined $j->{'command'}) {
          print $tee "+-- [step: $step] execute command: $j->{'command'}[$cmd_mg]\n";
          my $r = runGenericCommand( $j->{'command'}[$cmd_mg] );
          if (defined $r->{'commandResult'}){
            printf $tee "  . (!!) unexpected command result: %s", $r->{'commandResult'};
          }
          $cmd_mg++;
        }
      }
      case 'LOAD_IFILES' {
        if ( (defined $j->{'ifile'}) && (defined $j->{'options'}{'base_location'}) ) {
          print $tee "+-- [step: $step] uploading ifiles\n";
          foreach my $fl (sort keys %{ $j->{'ifile'} }) {
            print $tee "  ifile: $fl\n";
            my $pa = 'Common';
            if (defined $j->{'ifile'}{$fl}{'partition'}) {
              $pa = $j->{'ifile'}{$fl}{'partition'};
            }
            if (existsResource( "sys/file/ifile/~$pa~$fl")) {
              updateResource('ifile', $fl, $pa, $j->{'ifile'}{$fl}{'source'}, $j->{'options'});
            } else {
              createResource('ifile', $fl, $pa, $j->{'ifile'}{$fl}{'source'}, '', $j->{'options'});
            }
          }
        }
      }
      case 'LOAD_DG' {
        if ( (defined $j->{'datagroup'}) && (defined $j->{'options'}{'base_location'}) ) {
          print $tee "+-- [step: $step] uploading external data groups\n";
          foreach my $fl (sort keys %{ $j->{'datagroup'} }) {
            print $tee "  datagroup: $fl\n";
            my $pa = 'Common';
            my $tp = "string";
            if (defined $j->{'datagroup'}{$fl}{'partition'}) {
              $pa = $j->{'datagroup'}{$fl}{'partition'};
            }
            if (defined $j->{'datagroup'}{$fl}{'type'}) {
              $tp = $j->{'datagroup'}{$fl}{'type'};
            }
            if (existsResource( "sys/file/data-group/~$pa~$fl")) {
              updateResource('dgroup', $fl, $pa, $j->{'datagroup'}{$fl}{'source'}, $j->{'options'});
            } else {
              createResource('dgroup', $fl, $pa, $j->{'datagroup'}{$fl}{'source'}, $tp, $j->{'options'});
            }
          }
        }
      }
      case 'LOAD_MONITORS' {
        if ( (defined $j->{'monitor'}) && (defined $j->{'options'}{'base_location'}) ) {
          print $tee "+-- [step: $step] uploading external monitors\n";
          foreach my $fl (sort keys %{ $j->{'monitor'} }) {
            print $tee "  external monitor: $fl\n";
            my $pa = 'Common';
            if (defined $j->{'monitor'}{$fl}{'partition'}) {
              $pa = $j->{'monitor'}{$fl}{'partition'};
            }
            if (existsResource( "sys/file/external-monitor/~$pa~$fl")) {
              updateResource('monitor', $fl, $pa, $j->{'monitor'}{$fl}{'source'}, $j->{'options'});
            } else {
              createResource('monitor', $fl, $pa, $j->{'monitor'}{$fl}{'source'}, '', $j->{'options'});
            }
          }
        }
      }
      case 'DOWNLOAD' {
        if ( (defined $j->{'retrieve'}) && (defined $j->{'options'}{'store_location'}) ) {
          print $tee "+-- [step: $step] fetching files from remote system\n";
          foreach my $fl (sort keys %{ $j->{'retrieve'} }) {
            print $tee "  . resource from a location: $j->{'retrieve'}{$fl}\n";
            my $k = new CAudit( $host, $usr, $pass, $cport );
            $k->downloadResource($j->{'options'}, 'file', $j->{'retrieve'}{$fl}, $j->{'options'}{'store_location'} . '/' . $fl );
          }
        } else {
          print $tee "\033[31m! store_location or retrieve set not given\033[0m \n";
        }
      }
      case 'GET_ZONES' {
        if ((defined $j->{options}{encoding}) && ($j->{options}{encoding} eq 'json')) {
          my $k = new CAudit( $host, $usr, $pass, $cport );
          my $view = 'external';
          my $zs = $k->getZones($view);
          my $js = JSON->new;
          my $r = generate_JSON_response({ view => $view });
          my @items;
          $js->pretty();

          foreach my $zn (sort @{ $zs }) {
            push @items, $zn->{'zone_name'};
          }
          $r->{items} = \@items;
          print $tee $js->encode($r)
        }
        else {
          print $tee "+-- [step: $step] geting ZoneRunner zone names\n";
          my $k = new CAudit( $host, $usr, $pass, $cport );
          my $view = 'external';
          my $zs = $k->getZones($view);
          print $tee "configured zones in view \033[32m$view\033[0m\n";
          foreach my $zn (sort @{ $zs }) {
            print $tee "  $zn->{'zone_name'}\n";
          }
        }
      }
      else {
        print $tee "+-- [step: $step] \033[31munsupported batch command!\033[0m\n";
      }
    } # SWITCH
  }
}

# determine the file location in a batch
sub parseJsonFile
{
  my ($opts, $fname) = @_;
  my $json = qw();
  if (defined($opts->{"base_location"})) {
    my $localFile = $opts->{"base_location"} . $fname;
    if (! -e $localFile) {
      if (defined($opts->{"search_path"})) {
        #
        # TODO: cycle through search locations, so far only first item from the list
        foreach my $subpath (@{ $opts->{'search_path'} }) {
          $localFile = $opts->{"base_location"} . $subpath . "/" . $fname;
          if (-e $localFile) {
            last;
          }
        }
      }
    }
    if (-e $localFile) {
      my $content;
      open my $fh, "<", $localFile or terminate_with_error($tee, 'file open', "Error opening resource file: $localFile");
      read $fh, my $buffer, -s $fh;
      close($fh);
      $json = decode_json( $buffer );
    } else {
      terminate_with_error($tee, 'file open', "Error locating file: $localFile");
    }
  }
  return $json;
}

# parse filename from a path
sub parseFileToken
{
  my @fn = split( '/', shift );
  return $fn[$#fn];
}

#
# compute sha1 from a file contents
sub get_file_sha1
{
  my ($fn, $mode) = @_;
  open my $fh, "<", $fn or terminate_with_error($tee, 'file open', "Error opening resource file: $fn");
  read $fh, my $buffer, -s $fh;
  if ($mode eq 'iRule') { chomp($buffer); }
  close $fh;

  return sha1_hex( $buffer );
}

#
# get contents of a file into a buffer
sub get_file_content
{
  my ($fname) = @_;
  open my $fh, "<", $fname or terminate_with_error($tee, 'file open', "Error opening resource file: $fname");
  read $fh, my $buffer, -s $fh;
  close $fh;

  return $buffer;
}

#
# load irules onto F5 device
sub load_irules
{
  my $c = shift;
  my $f = shift;
  my %rls = checkRules();
  my @rs;

  # load file into buffer
  my %rules = ();

  if ($f and $f ne '') {
    print $tee "  . load_rules:: using ruleset definition: $f\n";
    %rules  = %{ $c->{'ruleset'}{$f} };
  } else {
    %rules = %{ $c->{'rules'} };
  }

  foreach my $prio (qw(1 2 3)) {
    foreach my $rl (sort keys %rules) {
      if (defined $rules{$rl}{'priority'} and $rules{$rl}{'priority'} == $prio) {
        push @rs, $rl;
      }
    }
  }

  foreach my $rl (sort keys %rules) {
    if (not defined $rules{$rl}{'priority'}) {
      push @rs, $rl;
    }
  }

  foreach my $rl ( @rs ) {
    my $partition = 'Common';
    my $fhss = "$c->{'options'}{rules_location}/$rl.tcl";
    if (defined $rules{$rl}{'partition'}) {
      if ($rules{$rl}{'partition'} ne 'Common') {
        $partition = $rules{$rl}{'partition'};
        $fhss = "$c->{'options'}{rules_location}/$partition/$rl.tcl";
      }
    }
    my $rname = "/$partition/$rl";
    my $fhss_sha = get_file_sha1( $fhss, 'iRule' );
    if (defined $rls{$rname}) {
      if ($fhss_sha ne $rls{$rname}{'hash'}) {
        print $tee "  . \x1b[34mupdating rule: /$partition/$rl\x1b[0m <local: $fhss_sha, remote: $rls{$rname}{'hash'}>\n";
        updateResource('rule', $rl, $partition, $fhss, undef);
      } else {
        print $tee "  . \x1b[32mrule: $rl is uptodate\x1b[0m <hash $fhss_sha>\n";
      }
    } else {
      print $tee "  . \x1b[33minstalling rule: /$partition/$rl\x1b[0m <hash $fhss_sha>\n";
      createResource('rule', $rl, $partition, $fhss, '', undef);
    }
  }
}

# Reports

#
# ISTATS generic report
sub report_istats_generic
{
  my $r = runGenericCommand("istats dump");
  if (defined( $r->{'commandResult'})) {
    print $tee "+-- Report::Istats\n";
    print $tee '-'x 90 . "\n";
    printf $tee " %12s | %12s | %32s | %-20s\n",'Module','Range','Variable', 'Value';
    print $tee '-'x 90 . "\n";
    foreach my $ln ( split "\n", $r->{commandResult} ) {
      if ($ln =~ /^\s+\[\s*?(.+?)\s*?\]\[\s*?(.+?)\s*?\] = (.+?) .*/) {
        my ($code,$scope) = split('=', $1);
        my $var = $2;
        my $val = $3;
        printf $tee " %12s | %12s | %32s | %-20s\n",$code,$scope,$var,$val;
      }
    }
    print $tee '-'x 90 . "\n";
  } else {
    print $tee "-- report failed.\n"
  }
}
#
# string trimming
sub ctrim
{
  my $str = shift;
  chomp($str);
  $str =~ s/[,;]//g;
  $str =~ s/^\s+|\s+$//g;
  return $str;
}

#
# compare DB variables
sub report_dbvars {
  my ($defs) = @_;

  my $dbs = query2object($URL . 'sys/db');
  print $tee '-' x 120 . "\n";
  printf " %48s | %24s | %24s | %8s \n", 'Variable', 'Wanted', 'Check', 'Status';
  print $tee '-' x 120 . "\n";
  foreach my $r ( @{ $dbs->{'items'} } )
  {
    if (grep { /^$r->{'fullPath'}$/ } keys %{ $defs })
    {
      my $state = "[\033[32mPASS\033[0m]";
      my $sval = $r->{'value'};
      if ($r->{'value'} ne $defs->{$r->{'fullPath'}}) {
        $state = "[\033[31mFAIL\033[0m]";
      }
      printf $tee " %48s | %24s | %24s | %8s\n", $r->{'fullPath'}, $defs->{$r->{'fullPath'}}, $r->{'value'}, $state;
    }
  }
  print $tee '-' x 120 . "\n";
}

# compare iRules on the Box vs a baseline
# uses a baseline option
sub report_irules
{
   my ($base, $diff, $j, $set) = @_;

   if ($base eq '') {
     print $tee "-- cannot compare iRule without a baseline directory <base>\n";
     return;
   }

   my $nset = 0;
   my $ndir = 0;
   my $ngod = 0;
   my $nmis = 0;
   my $ndif = 0;
   my %svar_local;
   my %svar_remote;
   my %parts;

   my $rlist = $j->{'rules'};
   if (defined $set and defined $j->{'ruleset'}) {
     $rlist = $j->{'ruleset'}{$set};
   }

   unless (defined $rlist) {
     print $tee "\033[34m- warning: no iRules defined in the batch file\033[0m\n";
   }

   # scan for partitions
   foreach my $r (keys %{ $rlist }) {
     if (defined($rlist->{$r}{'partition'}) and ($rlist->{$r}{'partition'} ne 'Common')) {
       $parts{$rlist->{$r}{'partition'}} = 1;
     }
   }

   # Common partition
   opendir my $dir, $base or terminate_with_error($tee, 'direcory open', "Cannot open directory $base");
   my @files = grep { /^.+?\.tcl$/ } readdir $dir;
   closedir $dir;

   # Other partitions
   foreach my $sdir (keys %parts) {
     opendir my $dir, "$base/$sdir" or terminate_with_error($tee, 'direcory open', "Cannot open directory $base/$sdir");
     my @tfs = grep { /^.+?\.tcl$/ } readdir $dir;
     closedir $dir;
     @files = (@files, map { "$sdir/$_" } @tfs);
   }

   my $rules = query2object( $URL . 'ltm/rule');
   my %failed = qw||;

   printf $tee " %50s\tStatus\n", "Rule name";
   print $tee '-' x 100 . "\n";

   # number of rules
   $ndir = $#files;
   $nset = scalar keys %{ $rlist };

   foreach my $f (sort @files) {

     my @tks = split("/", $f);
     if ($#tks > 1) {
       printf $tee " %50s\t[\033[31mERROR\033[0m]\n", $f;
       next;
     }
     my $la = $tks[$#tks];
     $la =~ s/.tcl//;
     my $pa = 'Common';
     if ($#tks == 1) {
       $pa = $tks[0];
     }

     # ensure that we have iRule that is on disk but not interested in sending it to a system
     if ($rlist) {
       if (! grep { /^$la$/ } keys %{ $rlist }) {
         printf $tee " %50s\t[\033[33mSKIP\033[0m]\n", "/$pa/$la";
         next;
       }
     }

     # retrieve data from file
     open my $fh, "<", $base . "/$f" or terminate_with_error($tee, 'file open', "Error opening resource file $f");
     read $fh, my $buffer, -s $fh;
     close $fh;

     # remove newline
     chomp($buffer);

     # compute sha1 digest on file
     my $oh = sha1_hex( $buffer );

     $f =~ s/.tcl//;
     printf $tee " %50s", "/$pa/$la";
     find_static_vars(\%svar_local, $buffer, $f);

     # iterate over iRules scanned from the remote system
     my $found = 0;
     foreach my $r ( @{ $rules->{'items'} } ) {

        if (($r->{'name'} eq $la) and ($r->{'partition'} eq $pa)) {
          $found = 1;
          my $ih = sha1_hex( $r->{'apiAnonymous'} );
          find_static_vars(\%svar_remote, $r->{'apiAnonymous'}, $f);
          if ($oh ne $ih) {
            if ($^O eq "MSWin32") {
              printf $tee "\t[FAIL] %d %d\n", length($buffer) , length($r->{'apiAnonymous'});
            } else {
              printf $tee "\t[\033[31mFAIL\033[0m] %d %d\n", length($buffer) , length($r->{'apiAnonymous'});
            }
            # my $df = diff \$r->{'apiAnonymous'}, \$buffer, { STYLE => "Unified" };
            # compare changes over time over the base
            my $df = diff \$buffer, \$r->{'apiAnonymous'}, { STYLE => "Unified" };
            $failed{$la} = $df;
            $ndif++;
          } else {
            print $tee "\t[\033[32mOK\033[0m] \n";
            $ngod++;
          }
          last;
        }
     }
     if (! $found) {
       print $tee "\t[\033[34mMISS\033[0m] \n";
       $nmis++;
     }

   }
   print $tee '-' x 100 . "\n";
   printf $tee ". irules found in reference directory:    %d\n", $ndir;
   printf $tee ". irules declared in a batch and checked: %d\n", $nset if $nset > 0;
   printf $tee ". stats: OK: %d, DIFF: %d, MISS: %d \n", $ngod, $ndif, $nmis;
   print $tee '-' x 100 . "\n";

   # analyze static variables
   print $tee ". static::namespace check\n";
   foreach my $svar (sort keys %svar_local) {
     next if $svar eq 'errors';
     if (defined $svar_remote{$svar}) {
       if ($svar_local{$svar}{'value'} ne $svar_remote{$svar}{'value'}) {
         printf $tee " \033[33mwarning\033[0m: static var change detected: \033[34m<$svar_local{$svar}{'rule_name'}> $svar\033[0m: local: $svar_local{$svar}{'value'}, remote: $svar_remote{$svar}{'value'} \033[0m\n";
       }
     } else {
       printf $tee " \033[33mwarning\033[0m: static var missing on remote: \033[34m<$svar_local{$svar}{'rule_name'}>$svar\033[0m \n";
     }
   }
   if (defined $svar_local{'errors'}) {
     print $tee "!! static::var errors:\n";
     foreach my $erk (@{ $svar_local{'errors'} }) {
       print $tee "  \033[1;31m" . $erk . "\033[0m\n";
     }
   }
   print $tee '-' x 100 . "\n";

   if ($diff eq "true") {
     foreach my $d (sort keys %failed) {
       if ($^O eq "MSWin32") {
         printf $tee "--- [%s]:\n", $d;
       } else {
         printf $tee "\033[32m--- [%s]:\033[0m\n", $d;
       }
       my @lines = split /[\n]/, $failed{$d};
       foreach my $l (@lines) {
         if ($l =~ /^\-/) {
           print $tee $l . "\n";
         } elsif ($l =~ /^\@\@/) {
           if ($^O eq "MSWin32") {
             printf $tee "%s\n", $l;
           } else {
             printf $tee "\033[35m%s\033[0m\n", $l;
           }
         } else {
           if ($^O eq "MSWin32") {
             printf $tee "%s\n", $l;
           } else {
             printf $tee "\033[33m%s\033[0m\n", $l;
           }
         }
       }
     }
   }
}
#
# Custom reports
sub run_custom_report
{
  print ". not implemented\n";
}
# EOF
